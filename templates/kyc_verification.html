<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verificación de Identidad KYC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Face Detection Libraries - Sistema más simple y confiable -->
    <script>
        // Sistema de detección facial REAL con JavaScript puro
        window.FaceDetectionUtils = {
            // Canvas para análisis de frames
            analysisCanvas: null,
            analysisContext: null,
            
            // Inicializar canvas de análisis
            initAnalysisCanvas() {
                this.analysisCanvas = document.createElement('canvas');
                this.analysisContext = this.analysisCanvas.getContext('2d');
                this.analysisCanvas.width = 320;
                this.analysisCanvas.height = 240;
            },
            
            // Detectar cambios de brillo en regiones de la cara
            detectFaceMovement(videoElement) {
                if (!this.analysisCanvas) this.initAnalysisCanvas();
                
                try {
                    // Verificar que el video está disponible
                    if (!videoElement || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                        return null;
                    }
                    
                    // Capturar frame del video
                    this.analysisContext.drawImage(videoElement, 0, 0, 320, 240);
                    const imageData = this.analysisContext.getImageData(0, 0, 320, 240);
                    const pixels = imageData.data;
                    
                    // Verificar que tenemos datos de imagen válidos
                    if (!pixels || pixels.length === 0) {
                        return null;
                    }
                    
                    // Analizar regiones específicas para detectar movimientos
                    const regions = {
                        center: this.analyzeRegion(pixels, 120, 80, 80, 80, 320), // Centro de la cara
                        left: this.analyzeRegion(pixels, 40, 80, 60, 80, 320),    // Izquierda
                        right: this.analyzeRegion(pixels, 220, 80, 60, 80, 320),  // Derecha
                        top: this.analyzeRegion(pixels, 120, 40, 80, 60, 320),    // Arriba
                        bottom: this.analyzeRegion(pixels, 120, 140, 80, 60, 320), // Abajo
                        mouth: this.analyzeRegion(pixels, 140, 160, 40, 30, 320)   // Zona boca
                    };
                    
                    // Verificar que las regiones tienen datos válidos
                    const overallBrightness = this.calculateOverallBrightness(pixels);
                    
                    // Solo retornar si hay suficiente brillo (rostro detectado)
                    if (overallBrightness > 30 && regions.center > 30) { // Umbrales más bajos
                        return {
                            regions,
                            movement: this.calculateMovement(regions),
                            brightness: overallBrightness,
                            faceDetected: true
                        };
                    } else if (overallBrightness > 15) { // Detectar presencia parcial
                        return {
                            regions,
                            movement: this.calculateMovement(regions),
                            brightness: overallBrightness,
                            faceDetected: false // Presente pero no claro
                        };
                    } else {
                        return null; // Sin presencia
                    }
                } catch (error) {
                    console.warn('Error en análisis de frame:', error);
                    return null;
                }
            },
            
            // Analizar región específica
            analyzeRegion(pixels, x, y, width, height, canvasWidth) {
                let totalBrightness = 0;
                let pixelCount = 0;
                
                for (let py = y; py < y + height; py++) {
                    for (let px = x; px < x + width; px++) {
                        const index = (py * canvasWidth + px) * 4;
                        if (index < pixels.length - 3) {
                            const r = pixels[index];
                            const g = pixels[index + 1];
                            const b = pixels[index + 2];
                            totalBrightness += (r + g + b) / 3;
                            pixelCount++;
                        }
                    }
                }
                
                return pixelCount > 0 ? totalBrightness / pixelCount : 0;
            },
            
            // Calcular movimiento basado en cambios de brillo
            calculateMovement(regions) {
                return {
                    horizontal: (regions.right - regions.left) / 255 * 100,
                    vertical: (regions.bottom - regions.top) / 255 * 100,
                    centerFocus: regions.center / 255 * 100
                };
            },
            
            // Calcular brillo general
            calculateOverallBrightness(pixels) {
                let total = 0;
                for (let i = 0; i < pixels.length; i += 16) { // Sample every 4th pixel
                    total += (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                }
                return total / (pixels.length / 16);
            }
        };
        
        console.log('🎯 Sistema de detección REAL inicializado');
    </script>
    <style>
        .step-active { @apply bg-blue-600 text-white; }
        .step-completed { @apply bg-green-600 text-white; }
        .step-inactive { @apply bg-gray-300 text-gray-600; }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-purple-50 min-h-screen">
    <div class="container mx-auto px-4 py-8" x-data="kycVerification()">
        
        <!-- Header -->
        <div class="text-center mb-12">
            <div class="inline-flex items-center justify-center w-20 h-20 bg-blue-600 rounded-full mb-4">
                <i class="fas fa-shield-alt text-3xl text-white"></i>
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Verificación de Identidad</h1>
            <p class="text-gray-600 text-lg">Complete el proceso paso a paso para verificar su identidad</p>
        </div>

        <!-- Progress Steps -->
        <div class="flex justify-center mb-12">
            <div class="flex items-center space-x-4">
                <!-- Step 1 -->
                <div class="flex items-center">
                    <div :class="getStepClass(1)" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg transition-all duration-300">
                        <i x-show="currentStep > 1" class="fas fa-check"></i>
                        <span x-show="currentStep <= 1">1</span>
                    </div>
                    <span class="ml-2 text-sm font-medium text-gray-700">Datos y DNI</span>
                </div>
                
                <div class="w-8 h-1 bg-gray-300 rounded"></div>
                
                <!-- Step 2 -->
                <div class="flex items-center">
                    <div :class="getStepClass(2)" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg transition-all duration-300">
                        <i x-show="currentStep > 2" class="fas fa-check"></i>
                        <span x-show="currentStep <= 2">2</span>
                    </div>
                    <span class="ml-2 text-sm font-medium text-gray-700">Selfie</span>
                </div>
                
                <div class="w-8 h-1 bg-gray-300 rounded"></div>
                
                <!-- Step 3 -->
                <div class="flex items-center">
                    <div :class="getStepClass(3)" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg transition-all duration-300">
                        <i x-show="currentStep > 3" class="fas fa-check"></i>
                        <span x-show="currentStep <= 3">3</span>
                    </div>
                    <span class="ml-2 text-sm font-medium text-gray-700">Video</span>
                </div>
                
                <div class="w-8 h-1 bg-gray-300 rounded"></div>
                
                <!-- Step 4 -->
                <div class="flex items-center">
                    <div :class="getStepClass(4)" class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg transition-all duration-300">
                        <i x-show="currentStep > 4" class="fas fa-check"></i>
                        <span x-show="currentStep <= 4">4</span>
                    </div>
                    <span class="ml-2 text-sm font-medium text-gray-700">Resultado</span>
                </div>
            </div>
        </div>

        <!-- Main Content Card -->
        <div class="max-w-4xl mx-auto">
            <div class="bg-white rounded-2xl shadow-2xl overflow-hidden">
                
                <!-- PASO 1: Datos Personales y DNI -->
                <div x-show="currentStep === 1" class="p-8">
                    <div class="text-center mb-8">
                        <i class="fas fa-user-edit text-5xl text-blue-600 mb-4"></i>
                        <h2 class="text-3xl font-bold text-gray-800 mb-2">Información Personal</h2>
                        <p class="text-gray-600">Complete sus datos y suba una foto de su DNI</p>
                    </div>

                    <div class="grid md:grid-cols-2 gap-8">
                        <!-- Formulario -->
                        <div class="space-y-6">
                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Apellidos</label>
                                    <input x-model="userData.lastName" type="text" placeholder="Ej: García López" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Nombre</label>
                                    <input x-model="userData.firstName" type="text" placeholder="Ej: Juan" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                            </div>
                            
                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Número de Documento</label>
                                    <input x-model="userData.documentNumber" type="text" placeholder="12345678X / AB123456C" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Nacionalidad</label>
                                    <select x-model="userData.nationality" 
                                            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                        <option value="">Seleccionar país</option>
                                        <option value="ESP">España (DNI)</option>
                                        <option value="FRA">Francia (CNI)</option>
                                        <option value="ITA">Italia (CI)</option>
                                        <option value="PRT">Portugal (CC)</option>
                                        <option value="DEU">Alemania (Personalausweis)</option>
                                        <option value="GBR">Reino Unido (ID Card)</option>
                                        <option value="USA">Estados Unidos (ID Card)</option>
                                        <option value="MEX">México (INE)</option>
                                        <option value="ARG">Argentina (DNI)</option>
                                        <option value="COL">Colombia (CC)</option>
                                        <option value="PER">Perú (DNI)</option>
                                        <option value="CHL">Chile (CI)</option>
                                        <option value="VEN">Venezuela (CI)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Fecha de nacimiento</label>
                                <input x-model="userData.birthDate" type="date" 
                                       class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            </div>
                            
                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Fecha de expedición</label>
                                    <input x-model="userData.issueDate" type="date" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Fecha de validez</label>
                                    <input x-model="userData.expiryDate" type="date" 
                                           class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                            </div>
                        </div>

                        <!-- Foto DNI -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-4">Foto del DNI (anverso)</label>
                            <div class="border-2 border-dashed border-blue-300 rounded-lg p-6 text-center hover:border-blue-500 transition-colors">
                                <i class="fas fa-id-card text-4xl text-blue-400 mb-4"></i>
                                <p class="text-gray-600 mb-4">Suba una foto clara de su DNI</p>
                                <input type="file" @change="handleDNIPhoto($event)" accept="image/*" class="hidden" id="dniPhoto">
                                <label for="dniPhoto" class="bg-blue-600 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-blue-700 transition-colors inline-block">
                                    <i class="fas fa-camera mr-2"></i>Seleccionar Foto
                                </label>
                            </div>
                            
                            <!-- Preview DNI -->
                            <div x-show="dniPhotoPreview" class="mt-4">
                                <img :src="dniPhotoPreview" class="w-full h-48 object-cover rounded-lg shadow-lg">
                            </div>

                            <!-- Validation Success Message -->
                            <div x-show="dniValidationPassed && extractedText" class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <div class="flex items-start">
                                    <i class="fas fa-check-circle text-green-600 mr-3 mt-1"></i>
                                    <div>
                                        <h4 class="font-semibold text-green-800 mb-2">✅ Documento Validado Correctamente</h4>
                                        <p class="text-sm text-green-700 mb-3">Todos los datos coinciden. El documento es válido y corresponde a la nacionalidad seleccionada.</p>
                                        <details class="text-xs">
                                            <summary class="cursor-pointer text-green-600 hover:text-green-800">Ver texto extraído (debug)</summary>
                                            <pre x-text="extractedText" class="text-green-700 mt-2 p-2 bg-green-100 rounded whitespace-pre-wrap max-h-24 overflow-y-auto"></pre>
                                        </details>
                                    </div>
                                </div>
                            </div>

                            <!-- Validation Error Message -->
                            <div x-show="dniPhotoPreview && !processing && !dniValidationPassed && step1Result" class="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                                <div class="flex items-start">
                                    <i class="fas fa-exclamation-triangle text-red-600 mr-3 mt-1"></i>
                                    <div>
                                        <h4 class="font-semibold text-red-800 mb-2">❌ Error en Validación del Documento</h4>
                                        <p class="text-sm text-red-700 mb-3">Los datos no coinciden con el documento. Corrige los datos o sube una foto más clara y vuelve a hacer clic en "Continuar".</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end mt-8">
                        <button @click="nextStep()" :disabled="!canProceedStep1() || processing" 
                                :class="canProceedStep1() && !processing ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-400 cursor-not-allowed'"
                                class="px-8 py-3 text-white rounded-lg font-medium transition-colors">
                            <span x-show="!processing">Continuar <i class="fas fa-arrow-right ml-2"></i></span>
                            <span x-show="processing">
                                <i class="fas fa-spinner fa-spin mr-2"></i>Validando documento...
                            </span>
                        </button>
                    </div>
                </div>

                <!-- PASO 2: Selfie con Cámara -->
                <div x-show="currentStep === 2" class="p-8">
                    <div class="text-center mb-8">
                        <i class="fas fa-camera text-5xl text-green-600 mb-4"></i>
                        <h2 class="text-3xl font-bold text-gray-800 mb-2">Captura tu Selfie</h2>
                        <p class="text-gray-600">Toma una foto de tu rostro para verificar tu identidad</p>
                    </div>

                    <div class="max-w-md mx-auto">
                        <!-- Camera Stream -->
                        <div class="relative bg-gray-100 rounded-lg overflow-hidden shadow-lg">
                            <video x-ref="selfieVideo" autoplay class="w-full h-80 object-cover" style="transform: scaleX(-1);"></video>
                            <canvas x-ref="selfieCanvas" class="hidden"></canvas>
                            
                            <!-- Overlay Guide -->
                            <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <div class="w-48 h-64 border-4 border-white rounded-full opacity-30"></div>
                            </div>
                        </div>

                        <!-- Camera Controls -->
                        <div class="mt-6 text-center space-y-4">
                            <!-- Botón de prueba de cámara -->
                            <div x-show="!cameraActive && !selfiePhoto" class="mb-4">
                                <button @click="testCamera()" class="bg-gray-500 text-white px-6 py-2 rounded-lg hover:bg-gray-600 transition-colors mr-2">
                                    <i class="fas fa-video mr-2"></i>Probar Cámara
                                </button>
                                <button @click="startSelfieCamera()" class="bg-green-600 text-white px-8 py-3 rounded-lg hover:bg-green-700 transition-colors">
                                    <i class="fas fa-camera mr-2"></i>Activar Cámara
                                </button>
                            </div>

                            <div x-show="cameraActive && !selfiePhoto">
                                <button @click="takeSelfie()" class="bg-blue-600 text-white px-8 py-3 rounded-lg hover:bg-blue-700 transition-colors">
                                    <i class="fas fa-camera mr-2"></i>Tomar Selfie
                                </button>
                            </div>

                            <div x-show="selfiePhoto && !processingStep2 && !selfieVerificationAttempted">
                                <img :src="selfiePhoto" class="w-full h-80 object-cover rounded-lg shadow-lg mb-4">
                                <div class="flex space-x-4 justify-center">
                                    <button @click="retakeSelfie()" class="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition-colors">
                                        <i class="fas fa-redo mr-2"></i>Repetir
                                    </button>
                                    <button @click="nextStep()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition-colors">
                                        <i class="fas fa-check mr-2"></i>Confirmar
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Estado de carga para verificación de selfie -->
                            <div x-show="processingStep2" class="text-center py-8">
                                <div class="inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mb-4">
                                    <i class="fas fa-cog fa-spin text-2xl text-blue-600"></i>
                                </div>
                                <p class="text-blue-600 font-medium mb-2">Verificando imagen...</p>
                                <p class="text-sm text-gray-500">Comparando con DNI, por favor espere...</p>
                            </div>
                            
                            <!-- Resultado de verificación fallida -->
                            <div x-show="selfieVerificationAttempted && !selfieVerificationPassed" class="text-center py-8">
                                <div class="inline-flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mb-4">
                                    <i class="fas fa-times text-2xl text-red-600"></i>
                                </div>
                                <p class="text-red-600 font-medium mb-2">Las imágenes no coinciden</p>
                                <p class="text-sm text-gray-600 mb-4">Por favor, tome otra foto más clara o con mejor iluminación</p>
                                <button @click="retakeSelfie()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                                    <i class="fas fa-redo mr-2"></i>Tomar otra foto
                                </button>
                            </div>
                            
                            <!-- Resultado de verificación exitosa -->
                            <div x-show="selfieVerificationAttempted && selfieVerificationPassed" class="text-center py-8">
                                <div class="inline-flex items-center justify-center w-16 h-16 bg-green-100 rounded-full mb-4">
                                    <i class="fas fa-check text-2xl text-green-600"></i>
                                </div>
                                <p class="text-green-600 font-medium mb-2">¡Verificación exitosa!</p>
                                <p class="text-sm text-gray-600 mb-4">La imagen coincide correctamente con el DNI</p>
                                <button @click="currentStep++" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition-colors">
                                    <i class="fas fa-arrow-right mr-2"></i>Continuar
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-between mt-8">
                        <button @click="previousStep()" class="px-6 py-3 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
                            <i class="fas fa-arrow-left mr-2"></i>Anterior
                        </button>
                    </div>
                </div>

                <!-- PASO 3: Verificación de Vida -->
                <div x-show="currentStep === 3" class="p-4">
                    <!-- Header minimalista -->
                    <div class="text-center mb-6">
                        <div class="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-r from-purple-500 to-indigo-600 rounded-full mb-3">
                            <i class="fas fa-shield-check text-2xl text-white"></i>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-1">Verificación de Identidad</h2>
                        <p class="text-gray-500 text-sm">Verificación biométrica en tiempo real</p>
                    </div>

                    <!-- Layout Professional: Video + Instrucciones lado a lado -->
                    <div class="flex flex-col lg:flex-row gap-6 max-w-6xl mx-auto">
                        
                        <!-- Panel Izquierdo: Video Principal -->
                        <div class="lg:w-2/3">
                            <div class="relative bg-gradient-to-br from-gray-900 to-gray-800 rounded-2xl overflow-hidden shadow-2xl">
                                <!-- Video Stream -->
                                <video x-ref="recordVideo" autoplay class="w-full h-96 lg:h-[500px] object-cover" 
                                       style="transform: scaleX(-1);"></video>
                                
                                <!-- Status indicators - Esquina superior -->
                                <div class="absolute top-4 left-4 right-4 flex justify-between items-start z-10">
                                    <!-- Recording Indicator -->
                                    <div x-show="recording" class="flex items-center bg-red-500 text-white px-3 py-2 rounded-full shadow-lg">
                                        <div class="w-2 h-2 bg-white rounded-full mr-2 animate-pulse"></div>
                                        <span class="text-sm font-semibold">GRABANDO</span>
                                    </div>
                                    
                                    <!-- Status general -->
                                    <div x-show="!recording && videoActive" class="bg-green-500 text-white px-3 py-2 rounded-full shadow-lg">
                                        <span class="text-sm font-semibold">PREPARADO</span>
                                    </div>
                                    
                                    <!-- Timer -->
                                    <div x-show="recording" class="bg-black bg-opacity-70 text-white px-4 py-2 rounded-full shadow-lg">
                                        <span x-text="recordingTime" class="text-sm font-mono font-bold"></span>
                                    </div>
                                </div>

                <!-- Guías faciales sutiles - SIN tapar cara -->
                <div x-show="videoActive && !recording" class="absolute inset-0 flex items-center justify-center pointer-events-none z-5">
                    <!-- Marco facial sutil -->
                    <div class="relative">
                        <!-- Esquinas del marco (como cámara profesional) -->
                        <div class="absolute -top-4 -left-4 w-8 h-8 border-l-4 border-t-4 border-white opacity-80 rounded-tl-lg"></div>
                        <div class="absolute -top-4 -right-4 w-8 h-8 border-r-4 border-t-4 border-white opacity-80 rounded-tr-lg"></div>
                        <div class="absolute -bottom-4 -left-4 w-8 h-8 border-l-4 border-b-4 border-white opacity-80 rounded-bl-lg"></div>
                        <div class="absolute -bottom-4 -right-4 w-8 h-8 border-r-4 border-b-4 border-white opacity-80 rounded-br-lg"></div>
                        
                        <!-- Área de rostro sugerida -->
                        <div class="w-48 h-64 bg-transparent border-2 border-dashed border-white opacity-50 rounded-3xl"></div>
                        
                        <!-- Texto de posicionamiento - ABAJO del marco -->
                        <div class="absolute -bottom-12 left-1/2 transform -translate-x-1/2 text-white text-center">
                            <div class="bg-black bg-opacity-60 rounded-full px-4 py-2 text-sm font-medium">
                                👤 Posicione su rostro en el marco
                            </div>
                        </div>
                    </div>
                </div>

                <!-- NUEVO: Marco dinámico durante grabación con feedback -->
                <div x-show="recording" class="absolute inset-0 flex items-center justify-center pointer-events-none z-5">
                    <div class="relative">
                        <!-- Marco dinámico que cambia de color según el progreso -->
                        <div class="absolute -top-4 -left-4 w-8 h-8 border-l-4 border-t-4 rounded-tl-lg transition-all duration-300"
                             :class="getFrameColorClass()"></div>
                        <div class="absolute -top-4 -right-4 w-8 h-8 border-r-4 border-t-4 rounded-tr-lg transition-all duration-300"
                             :class="getFrameColorClass()"></div>
                        <div class="absolute -bottom-4 -left-4 w-8 h-8 border-l-4 border-b-4 rounded-bl-lg transition-all duration-300"
                             :class="getFrameColorClass()"></div>
                        <div class="absolute -bottom-4 -right-4 w-8 h-8 border-r-4 border-b-4 rounded-br-lg transition-all duration-300"
                             :class="getFrameColorClass()"></div>
                        
                        <!-- Área de rostro con color dinámico -->
                        <div class="w-48 h-64 bg-transparent border-2 border-dashed rounded-3xl transition-all duration-300"
                             :class="getFrameColorClass()"></div>
                        
                        <!-- Feedback en tiempo real - ENCIMA del marco -->
                        <div class="absolute -top-20 left-1/2 transform -translate-x-1/2 text-center">
                            <div class="bg-black bg-opacity-80 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300"
                                 :class="getFeedbackTextClass()">
                                <span x-text="realTimeFeedback"></span>
                                <!-- NUEVO: Indicador de modo de detección -->
                                <div class="text-xs mt-1 opacity-75">
                                    <span x-show="detectionMode === 'basic'">🔄 Modo simulado</span>
                                    <span x-show="detectionMode === 'tensorflow'">🎯 IA avanzada</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>                                <!-- Indicador de progreso de instrucción - ABAJO del video -->
                                <div x-show="recording && currentInstruction" class="absolute bottom-4 left-4 right-4 z-10">
                                    <div class="bg-black bg-opacity-70 rounded-xl p-4">
                                        <div class="flex items-center justify-between text-white mb-2">
                                            <span class="text-lg font-semibold" x-text="currentInstruction?.title || 'Preparando...'"></span>
                                            <div class="text-2xl" x-text="currentInstruction?.icon || '⏳'"></div>
                                        </div>
                                        <div class="bg-gray-600 rounded-full h-2 mb-1">
                                            <div class="bg-gradient-to-r from-purple-500 to-indigo-500 h-2 rounded-full transition-all duration-300" 
                                                 :class="instructionProgress >= 100 ? 'bg-gradient-to-r from-green-500 to-emerald-500' : ''"
                                                 :style="`width: ${instructionProgress}%`"></div>
                                        </div>
                                        <p class="text-gray-300 text-sm" x-text="currentInstruction?.description || 'Iniciando verificación...'"></p>
                                        
                                        <!-- NUEVO: Contador de intentos y feedback específico -->
                                        <div x-show="currentInstruction?.attempts > 0" class="mt-2 text-yellow-300 text-xs">
                                            <i class="fas fa-redo mr-1"></i>
                                            Intento <span x-text="(currentInstruction?.attempts || 0) + 1"></span> - 
                                            <span x-text="getInstructionHint()"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Panel Derecho: Instrucciones y Controles -->
                        <div class="lg:w-1/3 space-y-6">
                            
                            <!-- Estado actual -->
                            <div x-show="!videoActive && !recordedVideo" class="bg-gradient-to-r from-purple-50 to-indigo-50 rounded-xl p-6 border border-purple-100">
                                <h3 class="font-bold text-purple-800 mb-3 flex items-center">
                                    <i class="fas fa-video mr-2"></i>
                                    Preparar Cámara
                                </h3>
                                <p class="text-purple-700 text-sm mb-4">Active su cámara para comenzar la verificación biométrica en tiempo real.</p>
                                <button @click="startVideoCamera()" class="w-full bg-gradient-to-r from-purple-600 to-indigo-600 text-white py-3 rounded-lg font-semibold hover:from-purple-700 hover:to-indigo-700 transition-all shadow-lg">
                                    <i class="fas fa-camera mr-2"></i>Activar Cámara
                                </button>
                            </div>

                            <!-- Instrucciones previas -->
                            <div x-show="videoActive && !recording && !recordedVideo" class="bg-blue-50 rounded-xl p-6 border border-blue-200">
                                <h3 class="font-bold text-blue-800 mb-4 flex items-center">
                                    <i class="fas fa-list-check mr-2"></i>
                                    Instrucciones
                                </h3>
                                <div class="space-y-3">
                                    <div class="flex items-start">
                                        <div class="w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs font-bold mr-3 mt-0.5">1</div>
                                        <p class="text-blue-700 text-sm">Posicione su rostro dentro del marco</p>
                                    </div>
                                    <div class="flex items-start">
                                        <div class="w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs font-bold mr-3 mt-0.5">2</div>
                                        <p class="text-blue-700 text-sm">Siga las instrucciones en tiempo real</p>
                                    </div>
                                    <div class="flex items-start">
                                        <div class="w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs font-bold mr-3 mt-0.5">3</div>
                                        <p class="text-blue-700 text-sm">Realice movimientos naturales y claros</p>
                                    </div>
                                    <div class="flex items-start">
                                        <div class="w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs font-bold mr-3 mt-0.5">4</div>
                                        <p class="text-blue-700 text-sm">El proceso dura aproximadamente 15 segundos</p>
                                    </div>
                                </div>
                                
                                <button @click="startLivenessRecording()" class="w-full mt-6 bg-gradient-to-r from-red-500 to-pink-500 text-white py-3 rounded-lg font-semibold hover:from-red-600 hover:to-pink-600 transition-all shadow-lg">
                                    <i class="fas fa-shield-check mr-2"></i>Iniciar Verificación
                                </button>
                            </div>

                            <!-- Status durante grabación -->
                            <div x-show="recording && !currentInstruction" class="bg-green-50 rounded-xl p-6 border border-green-200">
                                <div class="text-center">
                                    <div class="inline-flex items-center justify-center w-12 h-12 bg-green-100 rounded-full mb-3">
                                        <i class="fas fa-spinner fa-spin text-green-600 text-xl"></i>
                                    </div>
                                    <h3 class="font-bold text-green-800 mb-2">Preparando Verificación</h3>
                                    <p class="text-green-700 text-sm">Manténgase en posición mientras iniciamos el análisis...</p>
                                </div>
                            </div>

                            <!-- Próxima instrucción -->
                            <div x-show="recording && currentInstruction" class="bg-white rounded-xl p-6 border-2 border-purple-200 shadow-lg">
                                <div class="text-center">
                                    <div class="text-4xl mb-3" x-text="currentInstruction?.icon || '⏳'"></div>
                                    <h3 class="font-bold text-gray-800 mb-2" x-text="currentInstruction?.title || 'Cargando...'"></h3>
                                    <p class="text-gray-600 text-sm mb-4" x-text="currentInstruction?.description || 'Preparando instrucción...'"></p>
                                    
                                    <!-- Progress ring -->
                                    <div class="relative w-16 h-16 mx-auto">
                                        <svg class="w-16 h-16 transform -rotate-90" viewBox="0 0 64 64">
                                            <circle cx="32" cy="32" r="28" stroke-width="4" stroke="#e5e7eb" fill="none"></circle>
                                            <circle cx="32" cy="32" r="28" stroke-width="4" stroke="#8b5cf6" fill="none"
                                                    :stroke-dasharray="`${instructionProgress * 1.75} 175`"
                                                    class="transition-all duration-300"></circle>
                                        </svg>
                                        <div class="absolute inset-0 flex items-center justify-center">
                                            <span class="text-xs font-bold text-purple-600" x-text="`${Math.round(instructionProgress)}%`"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Resultado final -->
                            <div x-show="recordedVideo" class="bg-gradient-to-r from-green-50 to-emerald-50 rounded-xl p-6 border border-green-200">
                                <div class="text-center mb-4">
                                    <div class="inline-flex items-center justify-center w-12 h-12 bg-green-100 rounded-full mb-3">
                                        <i class="fas fa-check text-green-600 text-xl"></i>
                                    </div>
                                    <h3 class="font-bold text-green-800 mb-2">¡Verificación Completada!</h3>
                                    <p class="text-green-700 text-sm">Su identidad ha sido verificada exitosamente</p>
                                </div>
                                
                                <div class="flex space-x-3">
                                    <button @click="retakeVideo()" class="flex-1 bg-gray-600 text-white py-2 rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors">
                                        <i class="fas fa-redo mr-1"></i>Repetir
                                    </button>
                                    <button @click="nextStep()" class="flex-1 bg-gradient-to-r from-green-600 to-emerald-600 text-white py-2 rounded-lg text-sm font-medium hover:from-green-700 hover:to-emerald-700 transition-all">
                                        <i class="fas fa-check mr-1"></i>Continuar
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Video de resultado (cuando se completa) -->
                    <div x-show="recordedVideo" class="max-w-2xl mx-auto mt-6">
                        <video :src="recordedVideo" controls class="w-full h-64 rounded-xl shadow-lg"></video>
                    </div>

                    <div class="flex justify-between mt-8">
                        <button @click="previousStep()" class="px-6 py-3 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
                            <i class="fas fa-arrow-left mr-2"></i>Anterior
                        </button>
                    </div>
                </div>

                <!-- PASO 4: Verificación y Resultados -->
                <div x-show="currentStep === 4" class="p-8">
                    <div class="text-center mb-8">
                        <i class="fas fa-shield-check text-5xl text-indigo-600 mb-4"></i>
                        <h2 class="text-3xl font-bold text-gray-800 mb-2">Verificación en Proceso</h2>
                        <p class="text-gray-600">Analizando y comparando sus datos...</p>
                    </div>

                    <!-- Processing Animation -->
                    <div x-show="verifying" class="text-center mb-8">
                        <div class="inline-flex items-center justify-center w-20 h-20 bg-blue-100 rounded-full mb-4">
                            <i class="fas fa-cog fa-spin text-3xl text-blue-600"></i>
                        </div>
                        <p class="text-blue-600 font-medium">Procesando verificación...</p>
                        <div class="mt-4 max-w-md mx-auto">
                            <div class="bg-gray-200 rounded-full h-2">
                                <div class="bg-blue-600 h-2 rounded-full transition-all duration-1000" :style="`width: ${verificationProgress}%`"></div>
                            </div>
                            <p class="text-sm text-gray-600 mt-2" x-text="verificationStep"></p>
                        </div>
                    </div>

                    <!-- Results -->
                    <div x-show="!verifying && verificationComplete">
                        <div class="max-w-2xl mx-auto">
                            <!-- Success/Failure Icon -->
                            <div class="text-center mb-8">
                                <div :class="verificationResult.success ? 'bg-green-100' : 'bg-red-100'" class="inline-flex items-center justify-center w-24 h-24 rounded-full mb-4">
                                    <i :class="verificationResult.success ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'" class="text-4xl"></i>
                                </div>
                                <h3 :class="verificationResult.success ? 'text-green-800' : 'text-red-800'" class="text-2xl font-bold mb-2" 
                                    x-text="verificationResult.success ? 'Verificación Exitosa' : 'Verificación Fallida'"></h3>
                                <p :class="verificationResult.success ? 'text-green-600' : 'text-red-600'" class="text-lg" 
                                   x-text="verificationResult.message"></p>
                            </div>

                            <!-- Detailed Results -->
                            <div class="bg-gray-50 rounded-lg p-6 mb-6">
                                <h4 class="font-semibold text-gray-800 mb-4">🔍 Detalles de la Verificación:</h4>
                                
                                <!-- OCR Results -->
                                <div class="mb-6 p-4 bg-white rounded-lg border">
                                    <h5 class="font-medium text-gray-800 mb-3">📄 Datos Extraídos del Documento (OCR):</h5>
                                    <div class="bg-gray-100 rounded-lg p-3 mb-3">
                                        <pre x-text="verificationResult.extracted_text || extractedText || 'Sin datos extraídos'" class="text-sm text-gray-700 whitespace-pre-wrap max-h-32 overflow-y-auto"></pre>
                                    </div>
                                    <div class="flex items-center">
                                        <span class="text-gray-600 mr-2">Estado OCR:</span>
                                        <span :class="(verificationResult.extracted_text || extractedText) ? 'text-green-600' : 'text-red-600'" class="font-medium">
                                            <i :class="(verificationResult.extracted_text || extractedText) ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                            <span x-text="(verificationResult.extracted_text || extractedText) ? 'Texto extraído correctamente' : 'Error en extracción de texto'"></span>
                                        </span>
                                    </div>
                                </div>

                                <!-- Document Analysis Section -->
                                <div x-show="verificationResult && (verificationResult.document_analysis || verificationResult.success)" class="mb-6 p-4 bg-white rounded-lg border">
                                    <h5 class="font-medium text-gray-800 mb-4">🌍 Verificación de Documento Internacional</h5>
                                    
                                    <div class="space-y-4">
                                        <!-- Document Type & Country Verification -->
                                        <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                                            <div class="flex justify-between items-center mb-2">
                                                <h6 class="font-medium text-blue-800">Tipo de Documento:</h6>
                                                <span class="text-blue-700 font-semibold" x-text="verificationResult.document_analysis.document_type"></span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-sm text-gray-600">Correspondencia con país:</span>
                                                <span :class="verificationResult.document_analysis.country_match ? 'text-green-600' : 'text-red-600'" class="font-medium">
                                                    <i :class="verificationResult.document_analysis.country_match ? 'fas fa-check-circle' : 'fas fa-times-circle'" class="mr-1"></i>
                                                    <span x-text="verificationResult.document_analysis.country_match ? 'VÁLIDO' : 'NO VÁLIDO'"></span>
                                                </span>
                                            </div>
                                            <div x-show="!verificationResult.document_analysis.country_match" class="mt-2 text-sm text-red-600">
                                                ⚠️ El documento no corresponde al país seleccionado
                                            </div>
                                        </div>

                                        <!-- Document Validity -->
                                        <div class="p-3 rounded-lg" :class="verificationResult.document_analysis.is_valid_document ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'">
                                            <div class="flex items-center">
                                                <i :class="verificationResult.document_analysis.is_valid_document ? 'fas fa-certificate text-green-600' : 'fas fa-exclamation-triangle text-red-600'" class="mr-2"></i>
                                                <span class="font-medium" :class="verificationResult.document_analysis.is_valid_document ? 'text-green-800' : 'text-red-800'">
                                                    <span x-text="verificationResult.document_analysis.is_valid_document ? 'Documento Válido' : 'Documento Inválido'"></span>
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Data Comparison Section -->
                                <div x-show="verificationResult && (verificationResult.data_matches || verificationResult.success)" class="mb-6 p-4 bg-white rounded-lg border">
                                    <h5 class="font-medium text-gray-800 mb-4">📊 Comparación de Datos: Insertados vs Extraídos</h5>
                                    
                                    <div class="space-y-3">
                                        <!-- Name comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">Nombre:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Insertado:</span>
                                                <p class="font-medium" x-text="userData.firstName + ' ' + userData.lastName"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Extraído:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.name || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.name ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.name ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.name ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>

                                        <!-- Document Number comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">Número de Documento:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Insertado:</span>
                                                <p class="font-medium" x-text="userData.documentNumber"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Extraído:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.document_number || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.document_number ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.document_number ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.document_number ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>

                                        <!-- Birth Date comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">Fecha Nacimiento:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Insertado:</span>
                                                <p class="font-medium" x-text="userData.birthDate"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Extraído:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.birthdate || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.birthdate ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.birthdate ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.birthdate ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>

                                        <!-- Issue Date comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">Fecha Expedición:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Insertado:</span>
                                                <p class="font-medium" x-text="userData.issueDate"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Extraído:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.issue_date || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.issue_date ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.issue_date ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.issue_date ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>

                                        <!-- Expiry Date comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">Fecha Validez:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Insertado:</span>
                                                <p class="font-medium" x-text="userData.expiryDate"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Extraído:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.expiry_date || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.expiry_date ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.expiry_date ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.expiry_date ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>

                                        <!-- Country/Nationality comparison -->
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 p-3 border rounded-lg">
                                            <div>
                                                <span class="text-sm font-medium text-gray-600">País/Nacionalidad:</span>
                                            </div>
                                            <div>
                                                <span class="text-sm text-blue-700">Seleccionado:</span>
                                                <p class="font-medium" x-text="userData.nationality"></p>
                                            </div>
                                            <div>
                                                <span class="text-sm text-purple-700">Del Documento:</span>
                                                <p class="font-medium" x-text="verificationResult.extracted_data?.nationality || 'No extraído'"></p>
                                                <span :class="verificationResult.data_matches?.country ? 'text-green-600' : 'text-red-600'" class="text-sm">
                                                    <i :class="verificationResult.data_matches?.country ? 'fas fa-check' : 'fas fa-times'" class="mr-1"></i>
                                                    <span x-text="verificationResult.data_matches?.country ? 'Coincide' : 'No coincide'"></span>
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Summary of data matching -->
                                    <div class="mt-4 p-3 rounded-lg bg-blue-50 border border-blue-200">
                                        <div class="flex items-center mb-2">
                                            <i class="fas fa-chart-bar text-blue-600 mr-2"></i>
                                            <span class="font-medium text-blue-800">Resumen de Verificación de Datos</span>
                                        </div>
                                        <div class="grid grid-cols-2 gap-4 text-sm">
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">Nombre:</span>
                                                <i :class="verificationResult.data_matches?.name ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">Documento:</span>
                                                <i :class="verificationResult.data_matches?.document_number ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">Nacimiento:</span>
                                                <i :class="verificationResult.data_matches?.birthdate ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">Expedición:</span>
                                                <i :class="verificationResult.data_matches?.issue_date ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">Validez:</span>
                                                <i :class="verificationResult.data_matches?.expiry_date ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-600 mr-2">País:</span>
                                                <i :class="verificationResult.data_matches?.country ? 'fas fa-check text-green-600' : 'fas fa-times text-red-600'"></i>
                                            </div>
                                        </div>
                                        <div class="mt-3 p-2 bg-white rounded border">
                                            <p class="text-sm text-gray-700" x-text="verificationResult.details || 'Verificación completada'"></p>
                                        </div>
                                    </div>
                                </div>

                                <!-- Face Comparison Results -->
                                <div class="space-y-4">
                                    <div class="p-4 bg-white rounded-lg border">
                                        <div class="flex justify-between items-start">
                                            <div>
                                                <h5 class="font-medium text-gray-800">👤 DNI vs Selfie:</h5>
                                                <p class="text-sm text-gray-600">Comparación facial entre documento y selfie</p>
                                            </div>
                                            <span :class="verificationResult.dniMatch ? 'text-green-600' : 'text-red-600'" class="font-medium">
                                                <i :class="verificationResult.dniMatch ? 'fas fa-check-circle' : 'fas fa-times-circle'" class="mr-1"></i>
                                                <span x-text="verificationResult.dniMatch ? 'COINCIDE' : 'NO COINCIDE'"></span>
                                            </span>
                                        </div>
                                        <div x-show="!verificationResult.dniMatch" class="mt-2 text-sm text-red-600">
                                            ⚠️ La cara del DNI no coincide con el selfie tomado
                                        </div>
                                    </div>

                                    <div class="p-4 bg-white rounded-lg border">
                                        <div class="flex justify-between items-start">
                                            <div>
                                                <h5 class="font-medium text-gray-800">🎬 Selfie vs Video:</h5>
                                                <p class="text-sm text-gray-600">Verificación de vida - detección en video</p>
                                            </div>
                                            <span :class="verificationResult.videoMatch ? 'text-green-600' : 'text-red-600'" class="font-medium">
                                                <i :class="verificationResult.videoMatch ? 'fas fa-check-circle' : 'fas fa-times-circle'" class="mr-1"></i>
                                                <span x-text="verificationResult.videoMatch ? 'DETECTADO' : 'NO DETECTADO'"></span>
                                            </span>
                                        </div>
                                        <div x-show="!verificationResult.videoMatch" class="mt-2 text-sm text-red-600">
                                            ⚠️ No se detectó la persona del selfie en el video de verificación
                                        </div>
                                    </div>
                                </div>

                                <!-- Debug Information -->
                                <div x-show="verificationResult.debugInfo" class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                    <h5 class="font-medium text-yellow-800 mb-2">🐛 Información de Debugging:</h5>
                                    <ul class="text-sm text-yellow-700 space-y-1">
                                        <li x-show="verificationResult.debugInfo?.ocrLength">
                                            • Caracteres extraídos: <span x-text="verificationResult.debugInfo?.ocrLength"></span>
                                        </li>
                                        <li x-show="verificationResult.debugInfo?.filesUploaded">
                                            • Archivos subidos: <span x-text="verificationResult.debugInfo?.filesUploaded"></span>
                                        </li>
                                        <li x-show="verificationResult.debugInfo?.apiErrors">
                                            • Errores de API: <span x-text="verificationResult.debugInfo?.apiErrors"></span>
                                        </li>
                                        <li x-show="verificationResult.debugInfo?.processingTime">
                                            • Tiempo de procesamiento: <span x-text="verificationResult.debugInfo?.processingTime"></span>ms
                                        </li>
                                    </ul>
                                </div>

                                <!-- Summary -->
                                <div class="mt-4 p-3 rounded-lg" :class="verificationResult.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'">
                                    <div class="flex items-center">
                                        <i :class="verificationResult.success ? 'fas fa-shield-check' : 'fas fa-shield-times'" class="mr-2"></i>
                                        <strong x-text="verificationResult.success ? 'VERIFICACIÓN EXITOSA' : 'VERIFICACIÓN FALLIDA'"></strong>
                                    </div>
                                    <p class="text-sm mt-1" x-text="verificationResult.message"></p>
                                </div>
                            </div>

                            <!-- Action Buttons -->
                            <div class="text-center space-x-4">
                                <button @click="restartVerification()" class="bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition-colors">
                                    <i class="fas fa-redo mr-2"></i>Reiniciar Proceso
                                </button>
                                <button x-show="verificationResult.success" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors">
                                    <i class="fas fa-download mr-2"></i>Descargar Certificado
                                </button>
                            </div>
                        </div>
                    </div>

                    <div x-show="!verifying" class="flex justify-between mt-8">
                        <button @click="previousStep()" class="px-6 py-3 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
                            <i class="fas fa-arrow-left mr-2"></i>Anterior
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error Messages -->
        <div x-show="errorMessage" 
             class="fixed top-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow-lg z-50 max-w-md">
            <div class="flex items-center">
                <i class="fas fa-exclamation-circle mr-2"></i>
                <span x-text="errorMessage"></span>
                <button @click="errorMessage = ''" class="ml-4 text-xl">&times;</button>
            </div>
        </div>
    </div>

    <script>
        function kycVerification() {
            return {
                currentStep: 1,
                processing: false,
                errorMessage: '',
                
                // Step 1 Data
                userData: {
                    firstName: '',
                    lastName: '',
                    documentNumber: '',
                    nationality: '',
                    birthDate: '',
                    issueDate: '',
                    expiryDate: ''
                },
                dniPhotoFile: null,
                dniPhotoPreview: null,
                dniPhotoPath: null,
                extractedText: '',
                
                // GPT-4 Smart Analysis Results (legacy)
                gptVerification: null,
                gptExtractedData: null,
                gptDetails: '',
                
                // NUEVO: Step-by-step verification results
                dniValidationPassed: false,
                selfieVerificationPassed: false,
                livenessVerificationPassed: false,
                step1Result: null,
                step2Result: null,
                step3Result: null,
                
                // Step 2 Data
                cameraActive: false,
                selfiePhoto: null,
                faceDetected: false,
                facePosition: null,
                isStable: false,
                readyToCapture: false,
                faceGuide: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                faceDetectionInterval: null,
                stabilityCheck: {
                    positions: [],
                    threshold: 10, // pixels
                    requiredFrames: 15 // frames estables requeridos
                },
                
                // Step 3 Data
                videoActive: false,
                recording: false,
                recordingTime: '00:00',
                recordedVideo: null,
                mediaRecorder: null,
                recordingTimer: null,
                
                // Liveness Detection Data
                currentInstruction: null,
                instructionProgress: 0,
                instructionTimer: null,
                livenessInstructions: [
                    { 
                        icon: '👀', 
                        title: 'Mire a la cámara', 
                        description: 'Mantenga su rostro centrado',
                        type: 'lookAtCamera',
                        duration: 2000,
                        attempts: 0,
                        maxTime: 10000,
                        validationThreshold: 80
                    },
                    { 
                        icon: '🔄', 
                        title: 'Gire la cabeza despacio', 
                        description: 'Movimiento circular lento - gire a ambos lados',
                        type: 'headTurn',
                        duration: 4000,
                        attempts: 0,
                        maxTime: 15000,
                        validationThreshold: 60,
                        requiredAngle: 30
                    },
                    { 
                        icon: '↕️', 
                        title: 'Mueva la cabeza arriba y abajo', 
                        description: 'Asiente despacio - arriba y abajo',
                        type: 'headNod',
                        duration: 3000,
                        attempts: 0,
                        maxTime: 12000,
                        validationThreshold: 60,
                        requiredMovement: 15
                    },
                    { 
                        icon: '↔️', 
                        title: 'Mueva la cabeza izquierda y derecha', 
                        description: 'Niegue despacio - izquierda y derecha',
                        type: 'headShake',
                        duration: 3000,
                        attempts: 0,
                        maxTime: 12000,
                        validationThreshold: 60,
                        requiredMovement: 20
                    },
                    { 
                        icon: '😊', 
                        title: 'Sonría naturalmente', 
                        description: 'Sonrisa clara y manténgala por 2 segundos',
                        type: 'smile',
                        duration: 2000,
                        attempts: 0,
                        maxTime: 10000,
                        validationThreshold: 70,
                        requiredDuration: 2000
                    },
                    { 
                        icon: '👁️', 
                        title: 'Parpadee 3 veces', 
                        description: 'Parpadeos lentos y claros',
                        type: 'blink',
                        duration: 3000,
                        attempts: 0,
                        maxTime: 12000,
                        validationThreshold: 100,
                        requiredBlinks: 3
                    }
                ],
                currentInstructionIndex: 0,
                
                // NUEVO: Sistema de detección facial con múltiples fallbacks
                faceMesh: null,
                faceDetector: null, // TensorFlow detector
                faceDetectionActive: false,
                faceDetectionInterval: null,
                currentFaceData: null,
                previousFaceData: null,
                faceHistory: [],
                detectionMode: 'real', // 'real', 'basic'
                
                // NUEVO: Datos para detección REAL
                baselineFaceData: null, // Posición base del rostro
                movementThresholds: {
                    horizontal: 10, // Reducido para mayor sensibilidad
                    vertical: 8,    // Reducido para mayor sensibilidad
                    smile: 5,       // Reducido para detectar sonrisas más sutiles
                    blink: 15       // Reducido para detectar parpadeos más fácil
                },
                
                // Estados de validación por instrucción - NUEVOS TIEMPOS MÍNIMOS 5 SEGUNDOS
                instructionValidation: {
                    lookAtCamera: { 
                        completed: false, 
                        progress: 0, 
                        centeringScore: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO mirando al centro
                        validationPassed: false,   // Nueva validación estricta
                        timeValidating: 0          // Tiempo acumulado validando correctamente
                    },
                    headTurn: { 
                        completed: false, 
                        progress: 0, 
                        leftAngle: 0, 
                        rightAngle: 0, 
                        maxAngle: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO para girar izquierda y derecha
                        validationPassed: false,
                        timeValidating: 0
                    },
                    headNod: { 
                        completed: false, 
                        progress: 0, 
                        upMovement: 0, 
                        downMovement: 0, 
                        totalMovement: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO para asentir
                        validationPassed: false,
                        timeValidating: 0
                    },
                    headShake: { 
                        completed: false, 
                        progress: 0, 
                        leftMovement: 0, 
                        rightMovement: 0, 
                        totalMovement: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO para negar
                        validationPassed: false,
                        timeValidating: 0
                    },
                    smile: { 
                        completed: false, 
                        progress: 0, 
                        smileDetected: false, 
                        smileDuration: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO sonriendo
                        validationPassed: false,
                        timeValidating: 0
                    },
                    blink: { 
                        completed: false, 
                        progress: 0, 
                        blinkCount: 0, 
                        isBlinking: false, 
                        lastBlink: 0,
                        isDetecting: false,
                        lastDetection: Date.now(),
                        movementStart: null,
                        requiredDuration: 5000,    // ⭐ 5 SEGUNDOS MÍNIMO para parpadear varias veces
                        validationPassed: false,
                        timeValidating: 0
                    }
                },
                
                // Feedback en tiempo real
                realTimeFeedback: 'Posicione su rostro en el marco',
                instructionStartTime: null,
                
                // Step 4 Data
                verifying: false,
                processingStep2: false,
                selfieVerificationAttempted: false,
                verificationComplete: false,
                verificationProgress: 0,
                verificationStep: '',
                verificationResult: {
                    success: false,
                    message: '',
                    dniMatch: false,
                    videoMatch: false,
                    dataExtracted: false,
                    dataComparison: null
                },
                
                // NUEVO: Resultado específico de liveness con comparación video-selfie
                livenessVerificationResult: {
                    success: false,
                    matches_selfie: false,
                    matches_dni: false,
                    confidence: 0,
                    message: ''
                },
                
                // NUEVO: Variables para tracking de rutas de archivos
                dniPath: '',
                selfiePath: '',

                init() {
                    console.log('KYC Verification initialized');
                    // Inicializar MediaPipe Face Mesh cuando esté disponible
                    this.initializeFaceMesh();
                },

                // NUEVO: Inicializar sistema de detección facial
                async initializeFaceMesh() {
                    console.log('🎯 Inicializando sistema de detección SIMPLIFICADO...');
                    
                    // Usar solo modo básico simulado para máxima compatibilidad
                    this.detectionMode = 'basic';
                    this.faceDetector = null;
                    
                    console.log('✅ Sistema básico inicializado - Sin dependencias externas');
                },



                // NUEVO: Sistema de detección REAL - No más simulación
                simulateBasicFaceDetection() {
                    if (!this.currentInstruction) {
                        this.realTimeFeedback = 'Posicione su rostro en el marco';
                        return;
                    }
                    
                    // Usar análisis real del video en lugar de simulación
                    const faceData = this.analyzeVideoFrame();
                    
                    if (faceData && faceData.faceDetected) {
                        // Rostro detectado correctamente
                        this.realTimeFeedback = `✅ Rostro detectado - ${this.currentInstruction.text}`;
                        
                        // El análisis real maneja la detección de movimientos
                        if (this.recording && this.currentInstruction) {
                            this.validateCurrentInstructionRealTime();
                        }
                    } else if (faceData && !faceData.faceDetected) {
                        // Hay datos pero el rostro no es claro
                        this.realTimeFeedback = '⚠️ Rostro poco claro - Mejore la iluminación o acérquese más';
                        
                        // Reset progreso gradualmente si no hay detección clara
                        const validation = this.instructionValidation[this.currentInstruction.type];
                        if (validation.progress > 0) {
                            validation.progress = Math.max(0, validation.progress - 1);
                            this.instructionProgress = validation.progress;
                        }
                    } else {
                        // Sin datos faciales en absoluto - dar feedback
                        this.realTimeFeedback = '❌ No se detecta rostro - Acérquese a la cámara';
                        
                        // Usar sistema de fallback básico si falla completamente
                        this.fallbackToSimulation();
                    }
                },

                // Sistema de fallback si la detección real falla
                fallbackToSimulation() {
                    if (!this.currentInstruction) return;
                    
                    const elapsed = Date.now() - (this.instructionStartTime || Date.now());
                    const instructionDuration = this.currentInstruction.duration || 4000;
                    
                    // Permitir avance automático después de un tiempo en modo fallback
                    if (elapsed > instructionDuration * 1.5) { // 1.5x el tiempo normal
                        console.log('🔄 Usando modo fallback para avanzar');
                        const validation = this.instructionValidation[this.currentInstruction.type];
                        validation.completed = true;
                        validation.progress = 100;
                        this.completeCurrentInstruction();
                    } else {
                        // Mostrar progreso gradual en modo fallback
                        const validation = this.instructionValidation[this.currentInstruction.type];
                        const fallbackProgress = Math.min(100, (elapsed / (instructionDuration * 1.5)) * 100);
                        validation.progress = Math.max(validation.progress, fallbackProgress * 0.7); // Progreso más lento
                        this.instructionProgress = validation.progress;
                    }
                },

                // NUEVO: Validar instrucción actual en tiempo real
                validateCurrentInstructionRealTime() {
                    if (!this.currentFaceData || !this.currentInstruction) return;
                    
                    const instruction = this.currentInstruction;
                    const validation = this.instructionValidation[instruction.type];
                    let progressUpdated = false;
                    
                    switch (instruction.type) {
                        case 'lookAtCamera':
                            progressUpdated = this.validateLookAtCamera(validation);
                            break;
                        case 'headTurn':
                            progressUpdated = this.validateHeadTurn(validation);
                            break;
                        case 'headNod':
                            progressUpdated = this.validateHeadNod(validation);
                            break;
                        case 'headShake':
                            progressUpdated = this.validateHeadShake(validation);
                            break;
                        case 'smile':
                            progressUpdated = this.validateSmile(validation);
                            break;
                        case 'blink':
                            progressUpdated = this.validateBlink(validation);
                            break;
                    }
                    
                    // Actualizar progreso visual
                    if (progressUpdated) {
                        this.instructionProgress = validation.progress;
                        this.updateRealTimeFeedback(validation, instruction.type);
                        
                        // Verificar si se completó la instrucción
                        if (validation.completed && validation.progress >= instruction.validationThreshold) {
                            this.completeCurrentInstruction();
                        }
                    }
                    
                    // Verificar timeout
                    const elapsedTime = Date.now() - this.instructionStartTime;
                    if (elapsedTime > instruction.maxTime && !validation.completed) {
                        this.repeatCurrentInstruction('Tiempo agotado');
                    }
                },

                // NUEVO: Validar "mirar a la cámara"
                validateLookAtCamera(validation) {
                    const rotation = this.currentFaceData.headRotation;
                    
                    // Verificar que está mirando al centro (±10 grados)
                    const centeringScore = Math.max(0, 100 - Math.abs(rotation.horizontal * 2) - Math.abs(rotation.vertical * 2));
                    validation.centeringScore = centeringScore;
                    validation.progress = Math.min(100, centeringScore);
                    validation.completed = centeringScore >= 80;
                    
                    return true;
                },

                // NUEVO: Validar giro de cabeza
                validateHeadTurn(validation) {
                    const rotation = this.currentFaceData.headRotation;
                    const absHorizontal = Math.abs(rotation.horizontal);
                    
                    // Registrar máximo ángulo alcanzado
                    if (absHorizontal > validation.maxAngle) {
                        validation.maxAngle = absHorizontal;
                    }
                    
                    // Registrar movimientos a izquierda y derecha
                    if (rotation.horizontal < -15) validation.leftAngle = Math.max(validation.leftAngle, Math.abs(rotation.horizontal));
                    if (rotation.horizontal > 15) validation.rightAngle = Math.max(validation.rightAngle, Math.abs(rotation.horizontal));
                    
                    // Progreso basado en que haya girado a ambos lados
                    const leftProgress = Math.min(100, (validation.leftAngle / this.currentInstruction.requiredAngle) * 50);
                    const rightProgress = Math.min(100, (validation.rightAngle / this.currentInstruction.requiredAngle) * 50);
                    
                    validation.progress = leftProgress + rightProgress;
                    validation.completed = validation.leftAngle >= this.currentInstruction.requiredAngle && 
                                          validation.rightAngle >= this.currentInstruction.requiredAngle;
                    
                    return true;
                },

                // NUEVO: Validar movimiento vertical (asentir)
                validateHeadNod(validation) {
                    const rotation = this.currentFaceData.headRotation;
                    const absVertical = Math.abs(rotation.vertical);
                    
                    // Registrar movimientos arriba y abajo
                    if (rotation.vertical < -10) validation.upMovement = Math.max(validation.upMovement, Math.abs(rotation.vertical));
                    if (rotation.vertical > 10) validation.downMovement = Math.max(validation.downMovement, Math.abs(rotation.vertical));
                    
                    validation.totalMovement = validation.upMovement + validation.downMovement;
                    validation.progress = Math.min(100, (validation.totalMovement / (this.currentInstruction.requiredMovement * 2)) * 100);
                    validation.completed = validation.upMovement >= this.currentInstruction.requiredMovement && 
                                          validation.downMovement >= this.currentInstruction.requiredMovement;
                    
                    return true;
                },

                // NUEVO: Validar movimiento horizontal (negar)
                validateHeadShake(validation) {
                    const rotation = this.currentFaceData.headRotation;
                    
                    // Similar a headTurn pero para negación
                    if (rotation.horizontal < -15) validation.leftMovement = Math.max(validation.leftMovement, Math.abs(rotation.horizontal));
                    if (rotation.horizontal > 15) validation.rightMovement = Math.max(validation.rightMovement, Math.abs(rotation.horizontal));
                    
                    validation.totalMovement = validation.leftMovement + validation.rightMovement;
                    validation.progress = Math.min(100, (validation.totalMovement / (this.currentInstruction.requiredMovement * 2)) * 100);
                    validation.completed = validation.leftMovement >= this.currentInstruction.requiredMovement && 
                                          validation.rightMovement >= this.currentInstruction.requiredMovement;
                    
                    return true;
                },

                // NUEVO: Validar sonrisa
                validateSmile(validation) {
                    const mouthRatio = this.currentFaceData.mouthAspectRatio;
                    const isSmiling = mouthRatio > 3.5; // Threshold for smile detection
                    
                    if (isSmiling && !validation.smileDetected) {
                        validation.smileDetected = true;
                        validation.smileStartTime = Date.now();
                    } else if (isSmiling && validation.smileDetected) {
                        validation.smileDuration = Date.now() - validation.smileStartTime;
                        validation.progress = Math.min(100, (validation.smileDuration / this.currentInstruction.requiredDuration) * 100);
                        validation.completed = validation.smileDuration >= this.currentInstruction.requiredDuration;
                    } else if (!isSmiling) {
                        validation.smileDetected = false;
                        validation.smileDuration = 0;
                        validation.progress = 0;
                    }
                    
                    return true;
                },

                // NUEVO: Validar parpadeo
                validateBlink(validation) {
                    const ear = this.currentFaceData.eyeAspectRatio;
                    const isBlinking = ear < 0.25; // Threshold for blink detection
                    const now = Date.now();
                    
                    if (isBlinking && !validation.isBlinking && (now - validation.lastBlink) > 300) {
                        validation.blinkCount++;
                        validation.isBlinking = true;
                        validation.lastBlink = now;
                    } else if (!isBlinking) {
                        validation.isBlinking = false;
                    }
                    
                    validation.progress = Math.min(100, (validation.blinkCount / this.currentInstruction.requiredBlinks) * 100);
                    validation.completed = validation.blinkCount >= this.currentInstruction.requiredBlinks;
                    
                    return true;
                },

                getStepClass(step) {
                    if (step < this.currentStep) return 'step-completed';
                    if (step === this.currentStep) return 'step-active';
                    return 'step-inactive';
                },

                // NUEVO: Obtener clase CSS del marco según progreso
                getFrameColorClass() {
                    if (!this.currentInstruction) return 'border-white';
                    
                    if (this.instructionProgress >= 80) {
                        return 'border-green-400'; // Casi completado
                    } else if (this.instructionProgress >= 40) {
                        return 'border-yellow-400'; // En progreso
                    } else {
                        return 'border-red-400'; // Necesita más esfuerzo
                    }
                },

                // NUEVO: Obtener clase CSS del texto de feedback
                getFeedbackTextClass() {
                    if (!this.currentInstruction) return 'text-white';
                    
                    if (this.instructionProgress >= 80) {
                        return 'text-green-300';
                    } else if (this.instructionProgress >= 40) {
                        return 'text-yellow-300';
                    } else {
                        return 'text-red-300';
                    }
                },

                // NUEVO: Actualizar feedback en tiempo real - MEJORADO
                updateRealTimeFeedback(validation, instructionType) {
                    const attempts = this.currentInstruction?.attempts || 0;
                    const isEasy = attempts >= 2; // Después de 2 intentos se vuelve más fácil
                    
                    switch (instructionType) {
                        case 'lookAtCamera':
                            if (validation.centeringScore >= 80) {
                                this.realTimeFeedback = '✅ ¡Perfecto! Mantén la posición';
                            } else if (validation.centeringScore >= 50) {
                                this.realTimeFeedback = '🔄 Ajusta ligeramente hacia el centro';
                            } else {
                                this.realTimeFeedback = isEasy ? '👁️ Solo mira a la cámara' : '❌ Mira directamente a la cámara';
                            }
                            break;
                            
                        case 'headTurn':
                            if (validation.completed) {
                                this.realTimeFeedback = '✅ ¡Excelente! Giro completado';
                            } else if (validation.progress > 50) {
                                this.realTimeFeedback = '🔄 ¡Bien! Continúa girando despacio';
                            } else if (validation.progress > 20) {
                                this.realTimeFeedback = '↔️ Gira más hacia ambos lados';
                            } else {
                                this.realTimeFeedback = isEasy ? '🔄 Mueve la cabeza a los lados' : '🔄 Comienza girando despacio hacia un lado';
                            }
                            break;
                            
                        case 'headNod':
                            if (validation.completed) {
                                this.realTimeFeedback = '✅ ¡Perfecto! Movimiento completado';
                            } else if (validation.progress > 50) {
                                this.realTimeFeedback = '↕️ ¡Bien! Continúa arriba y abajo';
                            } else {
                                this.realTimeFeedback = isEasy ? '👍 Asiente con la cabeza' : '↕️ Mueve la cabeza arriba y abajo despacio';
                            }
                            break;
                            
                        case 'headShake':
                            if (validation.completed) {
                                this.realTimeFeedback = '✅ ¡Excelente! Negación completada';
                            } else if (validation.progress > 50) {
                                this.realTimeFeedback = '↔️ ¡Bien! Continúa izquierda y derecha';
                            } else {
                                this.realTimeFeedback = isEasy ? '👎 Niega con la cabeza' : '↔️ Mueve la cabeza izquierda y derecha';
                            }
                            break;
                            
                        case 'smile':
                            if (validation.completed) {
                                this.realTimeFeedback = '✅ ¡Sonrisa perfecta mantenida!';
                            } else if (validation.smileDetected) {
                                const remaining = Math.ceil((this.currentInstruction.requiredDuration - validation.smileDuration) / 1000);
                                this.realTimeFeedback = `😊 ¡Bien! Mantén ${remaining}s más`;
                            } else {
                                this.realTimeFeedback = isEasy ? '😊 Sonríe un poco' : '😊 Por favor, sonríe naturalmente';
                            }
                            break;
                            
                        case 'blink':
                            if (validation.completed) {
                                this.realTimeFeedback = '✅ ¡Perfecto! 3 parpadeos completados';
                            } else {
                                const remaining = this.currentInstruction.requiredBlinks - validation.blinkCount;
                                const easy = isEasy ? (remaining <= 1 ? '👁️ Un parpadeo más' : '👁️ Parpadea despacio') : `👁️ Faltan ${remaining} parpadeos lentos`;
                                this.realTimeFeedback = easy;
                            }
                            break;
                            
                        default:
                            this.realTimeFeedback = isEasy ? '🎯 Sigue la instrucción' : 'Sigue las instrucciones';
                    }
                    
                    // Añadir indicador de progreso si está en progreso
                    if (validation.progress > 0 && validation.progress < 100) {
                        this.realTimeFeedback += ` (${Math.round(validation.progress)}%)`;
                    }
                },

                // Completar instrucción actual - redirigir a versión estricta
                completeCurrentInstruction() {
                    this.completeCurrentInstructionStrict();
                },

                // NUEVO: Repetir instrucción actual
                repeatCurrentInstruction(reason = 'Inténtalo de nuevo') {
                    console.log(`🔄 Repitiendo instrucción: ${this.currentInstruction.type} - ${reason}`);
                    
                    // Incrementar contador de intentos
                    this.currentInstruction.attempts = (this.currentInstruction.attempts || 0) + 1;
                    
                    // Reset validación
                    const validation = this.instructionValidation[this.currentInstruction.type];
                    Object.keys(validation).forEach(key => {
                        if (typeof validation[key] === 'number') {
                            validation[key] = 0;
                        } else if (typeof validation[key] === 'boolean') {
                            validation[key] = false;
                        }
                    });
                    
                    // Hacer instrucción más fácil después de varios intentos
                    if (this.currentInstruction.attempts >= 3) {
                        this.currentInstruction.validationThreshold = Math.max(40, this.currentInstruction.validationThreshold - 20);
                        this.currentInstruction.requiredAngle = Math.max(15, (this.currentInstruction.requiredAngle || 30) - 10);
                        this.currentInstruction.requiredMovement = Math.max(8, (this.currentInstruction.requiredMovement || 15) - 5);
                    }
                    
                    // Reiniciar progreso
                    this.instructionProgress = 0;
                    this.instructionStartTime = Date.now();
                    this.realTimeFeedback = `${reason} - Intento ${this.currentInstruction.attempts + 1}`;
                },

                // NUEVO: Obtener pista de ayuda según intentos
                getInstructionHint() {
                    if (!this.currentInstruction) return '';
                    
                    const attempts = this.currentInstruction.attempts || 0;
                    const type = this.currentInstruction.type;
                    
                    const hints = {
                        lookAtCamera: [
                            'Mira directamente a la lente',
                            'Centra tu rostro en el marco',
                            'Mantén la cabeza quieta'
                        ],
                        headTurn: [
                            'Gira despacio hacia ambos lados',
                            'Movimiento más amplio, como mirar por encima del hombro',
                            'Gira al menos 30° hacia cada lado'
                        ],
                        headNod: [
                            'Asiente despacio arriba y abajo',
                            'Movimiento más pronunciado, como decir "sí"',
                            'Baja y sube la barbilla claramente'
                        ],
                        headShake: [
                            'Niega despacio izquierda y derecha',
                            'Como decir "no" con la cabeza',
                            'Movimiento horizontal más amplio'
                        ],
                        smile: [
                            'Sonríe naturalmente durante 2 segundos',
                            'Sonrisa más amplia y mantenida',
                            'Muestra los dientes ligeramente'
                        ],
                        blink: [
                            'Parpadea 3 veces despacio',
                            'Parpadeos más lentos y marcados',
                            'Cierra y abre los ojos completamente'
                        ]
                    };
                    
                    return hints[type] ? hints[type][Math.min(attempts, hints[type].length - 1)] : 'Sigue las instrucciones';
                },

                async nextStep() {
                    // PASO 1: Validar DNI automáticamente
                    if (this.currentStep === 1) {
                        if (!this.canProceedStep1()) {
                            this.showError('Complete todos los campos obligatorios y suba la foto del DNI');
                            return;
                        }
                        
                        // Si no se ha validado aún, hacerlo automáticamente
                        if (!this.dniValidationPassed) {
                            console.log('🚀 Validando DNI automáticamente...');
                            await this.extractDNIText();
                            
                            // Si la validación falló, no continuar
                            if (!this.dniValidationPassed) {
                                this.showError('La validación del DNI no fue exitosa. Revise los datos e intente nuevamente.');
                                return;
                            }
                        }
                    }
                    
                    // PASO 2: Validar selfie
                    if (this.currentStep === 2) {
                        if (!this.selfiePhoto) {
                            this.showError('Tome una foto selfie antes de continuar');
                            return;
                        }
                        
                        // Si no se ha verificado el selfie, hacerlo ahora
                        if (!this.selfieVerificationPassed) {
                            console.log('🤳 Ejecutando verificación de selfie...');
                            await this.verifySelfie();
                            
                            // Si la verificación falló, no continuar
                            if (!this.selfieVerificationPassed) {
                                return; // El error ya se muestra en verifySelfie()
                            }
                        }
                    }
                    
                    // PASO 3: Validar video
                    if (this.currentStep === 3 && !this.canProceedStep3()) {
                        this.showError('Complete la verificación del video antes de continuar');
                        return;
                    }
                    
                    if (this.currentStep === 3) {
                        this.startVerification();
                    }
                    this.currentStep++;
                },

                previousStep() {
                    if (this.currentStep > 1) {
                        this.currentStep--;
                    }
                },

                // Step 1 Functions
                handleDNIPhoto(event) {
                    const file = event.target.files[0];
                    if (file) {
                        this.dniPhotoFile = file;
                        const reader = new FileReader();
                        reader.onload = (e) => this.dniPhotoPreview = e.target.result;
                        reader.readAsDataURL(file);
                    }
                },

                async extractDNIText() {
                    if (!this.dniPhotoFile) return;
                    
                    this.processing = true;
                    try {
                        console.log('📋 PASO 1: Validando DNI con nuevo endpoint modular');
                        
                        // Usar el nuevo endpoint modular /kyc/validate-dni
                        const formData = new FormData();
                        formData.append('firstName', this.userData.firstName);
                        formData.append('lastName', this.userData.lastName);
                        formData.append('documentNumber', this.userData.documentNumber);
                        formData.append('nationality', this.userData.nationality);
                        formData.append('birthDate', this.userData.birthDate);
                        formData.append('issueDate', this.userData.issueDate);
                        formData.append('expiryDate', this.userData.expiryDate);
                        formData.append('dniImageFront', this.dniPhotoFile);
                        
                        const dniResponse = await fetch('/kyc/validate-dni', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!dniResponse.ok) {
                            throw new Error('Error en validación de DNI');
                        }
                        
                        const dniResult = await dniResponse.json();
                        console.log('📋 Resultado validación DNI:', dniResult);
                        
                        // Guardar resultados del paso 1
                        this.step1Result = dniResult;
                        this.dniPhotoPath = dniResult.dni_front_path;
                        this.dniPath = dniResult.dni_front_path; // Para la comparación final de liveness
                        
                        // Determinar si puede pasar al siguiente paso
                        this.dniValidationPassed = dniResult.success && 
                                                   dniResult.recommendation !== 'REJECT' && 
                                                   dniResult.confidence >= 60; // Umbral mínimo
                        
                        if (this.dniValidationPassed) {
                            console.log('✅ DNI validado correctamente - puede continuar');
                            // Solo mostrar texto extraído si es exitoso
                            this.extractedText = dniResult.extracted_text || 'Datos extraídos con GPT-4 Vision';
                            this.showSuccess('DNI validado correctamente. Puede continuar al siguiente paso.');
                            
                            // Guardar datos GPT para mostrar después
                            this.gptVerification = {
                                name_match: dniResult.data_matches?.name || false,
                                dni_match: dniResult.data_matches?.document_number || false,
                                birthdate_match: dniResult.data_matches?.birthdate || false,
                                address_match: dniResult.data_matches?.address || false,
                                overall_confidence: dniResult.confidence || 0,
                                recommendation: dniResult.recommendation || 'REVIEW'
                            };
                            this.gptExtractedData = dniResult.extracted_data || {};
                            this.gptDetails = dniResult.details || 'Análisis completado con GPT-4 Vision';
                        } else {
                            console.log('❌ DNI no válido - no puede continuar');
                            
                            // NO mostrar texto extraído en caso de error
                            this.extractedText = '';
                            
                            // Mensaje de error sencillo
                            this.showError('Los datos del documento no coinciden con la información proporcionada. Verifique los datos introducidos o suba una foto más clara del documento.');
                        }
                        
                    } catch (error) {
                        console.error('❌ Error en validación DNI:', error);
                        this.showError('Error al validar DNI: ' + error.message);
                        this.dniValidationPassed = false;
                    } finally {
                        this.processing = false;
                    }
                },

                canProceedStep1() {
                    // Solo verificar que los campos básicos estén llenos, no la validación aún
                    return this.userData.firstName && 
                           this.userData.lastName &&
                           this.userData.documentNumber && 
                           this.userData.nationality &&
                           this.userData.birthDate && 
                           this.userData.issueDate &&
                           this.userData.expiryDate &&
                           this.dniPhotoFile; // Campos básicos obligatorios
                },

                retryDocumentValidation() {
                    // Resetear el estado de validación para permitir un nuevo intento
                    this.dniValidationPassed = false;
                    this.step1Result = null;
                    this.extractedText = '';
                    this.errorMessage = '';
                    
                    console.log('🔄 Estado de validación reseteado - listo para nuevo intento');
                },

                // Step 2 Functions
                async startSelfieCamera() {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { width: 640, height: 480 } 
                        });
                        this.$refs.selfieVideo.srcObject = stream;
                        this.cameraActive = true;
                    } catch (error) {
                        this.showError('No se pudo acceder a la cámara');
                    }
                },

                async takeSelfie() {
                    const video = this.$refs.selfieVideo;
                    const canvas = this.$refs.selfieCanvas;
                    const context = canvas.getContext('2d');
                    
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    context.scale(-1, 1);
                    context.drawImage(video, -canvas.width, 0);
                    
                    this.selfiePhoto = canvas.toDataURL('image/jpeg');
                    this.stopCamera(video);
                    
                    // NUEVO: Verificar automáticamente el selfie con endpoint modular
                    await this.verifySelfie();
                },

                async verifySelfie() {
                    if (!this.selfiePhoto || !this.dniPhotoPath) return;
                    
                    this.processingStep2 = true;
                    this.selfieVerificationAttempted = false;
                    
                    try {
                        console.log('🤳 PASO 2: Verificando selfie con nuevo endpoint modular');
                        
                        // Convertir selfie a archivo
                        const selfieFile = this.dataURLtoFile(this.selfiePhoto, 'selfie.jpg');
                        
                        // Usar el nuevo endpoint modular /kyc/verify-selfie
                        const formData = new FormData();
                        formData.append('dniImagePath', this.dniPhotoPath);
                        formData.append('selfieImage', selfieFile);
                        
                        const selfieResponse = await fetch('/kyc/verify-selfie', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!selfieResponse.ok) {
                            throw new Error('Error en verificación de selfie');
                        }
                        
                        const selfieResult = await selfieResponse.json();
                        console.log('🤳 Resultado verificación selfie:', selfieResult);
                        
                        // Guardar resultados del paso 2
                        this.step2Result = selfieResult;
                        this.selfiePath = selfieResult.selfie_path; // Para la comparación final de liveness
                        
                        // Determinar si puede pasar al siguiente paso (ACEPTA REVIEW también)
                        this.selfieVerificationPassed = selfieResult.success && 
                                                       (selfieResult.face_match || 
                                                        selfieResult.recommendation === 'APPROVE' || 
                                                        selfieResult.recommendation === 'REVIEW') && 
                                                       selfieResult.confidence >= 30; // Umbral muy bajo
                        
                        // Marcar que se intentó la verificación
                        this.selfieVerificationAttempted = true;
                        
                        if (this.selfieVerificationPassed) {
                            console.log('✅ Selfie verificado correctamente - puede continuar');
                        } else {
                            console.log('❌ Selfie no válido - no puede continuar');
                        }
                        
                    } catch (error) {
                        console.error('❌ Error en verificación selfie:', error);
                        this.selfieVerificationPassed = false;
                        this.selfieVerificationAttempted = true;
                    } finally {
                        this.processingStep2 = false;
                    }
                },

                retakeSelfie() {
                    this.selfiePhoto = null;
                    this.selfieVerificationPassed = false; // Reset verificación
                    this.selfieVerificationAttempted = false; // Reset intento
                    this.step2Result = null;
                    this.startSelfieCamera();
                },

                canProceedStep2() {
                    return this.selfiePhoto && 
                           this.selfieVerificationPassed; // NUEVO: requiere verificación exitosa del selfie
                },

                // Step 3 Functions
                async startVideoCamera() {
                    try {
                        // Verificar si getUserMedia está disponible
                        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                            throw new Error('Tu navegador no soporta acceso a la cámara. Usa Chrome, Firefox, Safari o Edge.');
                        }

                        // Verificar permisos de cámara
                        const permissions = await navigator.permissions.query({ name: 'camera' });
                        if (permissions.state === 'denied') {
                            throw new Error('Permisos de cámara denegados. Habilita la cámara en la configuración del navegador.');
                        }

                        console.log('📹 Iniciando cámara para video...');
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { 
                                width: { ideal: 640, min: 320 },
                                height: { ideal: 480, min: 240 },
                                facingMode: 'user' // Cámara frontal
                            },
                            audio: true
                        });
                        
                        this.$refs.recordVideo.srcObject = stream;
                        this.videoActive = true;
                        console.log('✅ Cámara de video iniciada correctamente');
                        
                    } catch (error) {
                        console.error('❌ Error iniciando cámara de video:', error);
                        
                        let errorMessage = 'No se pudo acceder a la cámara';
                        
                        if (error.name === 'NotAllowedError') {
                            errorMessage = 'Permisos de cámara denegados. Habilita la cámara en tu navegador.';
                        } else if (error.name === 'NotFoundError') {
                            errorMessage = 'No se encontró ninguna cámara conectada.';
                        } else if (error.name === 'NotReadableError') {
                            errorMessage = 'La cámara está siendo usada por otra aplicación.';
                        } else if (error.name === 'OverconstrainedError') {
                            errorMessage = 'La cámara no soporta la resolución solicitada.';
                        } else if (error.name === 'SecurityError') {
                            errorMessage = 'Acceso a la cámara bloqueado por seguridad. Usa HTTPS.';
                        } else if (error.message.includes('HTTPS')) {
                            errorMessage = 'Se requiere HTTPS para acceder a la cámara.';
                        }
                        
                        this.showError(errorMessage);
                        this.videoActive = false;
                    }
                },

                startLivenessRecording() {
                    const stream = this.$refs.recordVideo.srcObject;
                    this.mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        chunks.push(event.data);
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        this.recordedVideo = URL.createObjectURL(blob);
                    };
                    
                    this.mediaRecorder.start();
                    this.recording = true;
                    this.currentInstructionIndex = 0;
                    this.startRecordingTimer();
                    
                    // NUEVO: Iniciar detección facial en tiempo real
                    this.startFaceDetection();
                    
                    // NUEVO: Iniciar secuencia con detección inteligente
                    this.startIntelligentLivenessSequence();
                },

                // NUEVO: Iniciar detección facial en tiempo real
                startFaceDetection() {
                    this.faceDetectionActive = true;
                    
                    console.log('🎯 Iniciando sistema de detección REAL...');
                    
                    // Sistema REAL de análisis de video con Canvas
                    this.faceDetectionInterval = setInterval(() => {
                        if (this.faceDetectionActive) {
                            this.simulateBasicFaceDetection(); // Ahora usa análisis real, no simulación
                        }
                    }, 200); // Más frecuente para mejor detección real (5 FPS)
                    
                    console.log('✅ Sistema de detección REAL iniciado - Analizando movimientos reales del usuario');
                },

                // NUEVO: Sistema básico de detección (ya no necesario)
                startBasicFaceDetection() {
                    console.log('🔄 Sistema básico siempre activo');
                },

                // NUEVO: Secuencia inteligente de liveness
                startIntelligentLivenessSequence() {
                    // Esperar 1 segundo antes de comenzar
                    setTimeout(() => {
                        this.startNextInstruction();
                    }, 1000);
                },

                // NUEVO: Iniciar siguiente instrucción con sistema estricto
                startNextInstruction() {
                    this.startNextInstructionStrict();
                },

                async stopLivenessRecording() {
                    // Redirigir a la nueva función que incluye comparación
                    this.completeLivenessWithComparison();
                },

                async verifyLiveness() {
                    if (!this.recordedVideo || !this.selfiePhoto || !this.dniPhotoPath) return;
                    
                    this.processing = true;
                    try {
                        console.log('🎥 PASO 3: Verificando liveness con nuevo endpoint modular');
                        
                        // Convertir video blob a archivo
                        const videoBlob = await fetch(this.recordedVideo).then(res => res.blob());
                        const videoFile = new File([videoBlob], 'verification_video.mp4', { type: 'video/mp4' });
                        
                        // Obtener path del selfie (necesario para la verificación)
                        const selfieFile = this.dataURLtoFile(this.selfiePhoto, 'selfie.jpg');
                        const selfieFormData = new FormData();
                        selfieFormData.append('image', selfieFile);
                        
                        const selfieUpload = await fetch('/upload', {
                            method: 'POST',
                            body: selfieFormData
                        });
                        
                        if (!selfieUpload.ok) {
                            throw new Error('Error al subir selfie para verificación');
                        }
                        
                        const selfieData = await selfieUpload.json();
                        const selfieImagePath = selfieData.path;
                        
                        // Usar el nuevo endpoint modular /kyc/verify-liveness
                        const formData = new FormData();
                        formData.append('selfieImagePath', selfieImagePath);
                        formData.append('dniImagePath', this.dniPhotoPath);
                        formData.append('verificationVideo', videoFile);
                        
                        const livenessResponse = await fetch('/kyc/verify-liveness', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!livenessResponse.ok) {
                            throw new Error('Error en verificación de liveness');
                        }
                        
                        const livenessResult = await livenessResponse.json();
                        console.log('🎥 Resultado verificación liveness:', livenessResult);
                        
                        // Guardar resultados del paso 3
                        this.step3Result = livenessResult;
                        
                        // Determinar si puede pasar al siguiente paso
                        this.livenessVerificationPassed = livenessResult.success && 
                                                          livenessResult.is_live_person && 
                                                          livenessResult.matches_selfie && 
                                                          livenessResult.recommendation !== 'REJECT' && 
                                                          livenessResult.confidence >= 60; // Umbral mínimo
                        
                        if (this.livenessVerificationPassed) {
                            console.log('✅ Liveness verificado correctamente - puede continuar');
                            this.showSuccess('Video de vida verificado correctamente. Puede ver el resultado final.');
                        } else {
                            console.log('❌ Liveness no válido - no puede continuar');
                            this.showError(`Video no verificado: ${livenessResult.recommendation}. Confianza: ${livenessResult.confidence}%`);
                        }
                        
                    } catch (error) {
                        console.error('❌ Error en verificación liveness:', error);
                        this.showError('Error al verificar video: ' + error.message);
                        this.livenessVerificationPassed = false;
                    } finally {
                        this.processing = false;
                    }
                },

                retakeVideo() {
                    console.log('🔄 Reiniciando captura de video...');
                    
                    // Limpiar video y estados
                    this.recordedVideo = null;
                    this.livenessVerificationPassed = false;
                    this.step3Result = null;
                    
                    // Limpiar instrucciones y detección facial
                    this.currentInstruction = null;
                    this.currentInstructionIndex = 0;
                    this.instructionProgress = 0;
                    this.faceDetectionActive = false;
                    this.currentFaceData = null;
                    this.realTimeFeedback = 'Posicione su rostro en el marco';
                    
                    // Limpiar timers
                    if (this.instructionTimer) {
                        clearInterval(this.instructionTimer);
                        this.instructionTimer = null;
                    }
                    if (this.faceDetectionInterval) {
                        clearInterval(this.faceDetectionInterval);
                        this.faceDetectionInterval = null;
                    }
                    
                    // Reset validaciones de instrucciones
                    Object.keys(this.instructionValidation).forEach(key => {
                        const validation = this.instructionValidation[key];
                        Object.keys(validation).forEach(prop => {
                            if (typeof validation[prop] === 'number') {
                                validation[prop] = 0;
                            } else if (typeof validation[prop] === 'boolean') {
                                validation[prop] = false;
                            }
                        });
                    });
                    
                    // Reset intentos en instrucciones
                    this.livenessInstructions.forEach(instruction => {
                        instruction.attempts = 0;
                        // Restaurar valores originales si fueron modificados
                        instruction.validationThreshold = this.getOriginalValidationThreshold(instruction.type);
                    });
                    
                    // Reiniciar cámara
                    this.startVideoCamera();
                },

                // NUEVO: Obtener threshold original de validación
                getOriginalValidationThreshold(type) {
                    const originalThresholds = {
                        lookAtCamera: 80,
                        headTurn: 60,
                        headNod: 60,
                        headShake: 60,
                        smile: 70,
                        blink: 100
                    };
                    return originalThresholds[type] || 60;
                },

                canProceedStep3() {
                    return this.recordedVideo && 
                           this.livenessVerificationPassed; // NUEVO: requiere verificación exitosa del video
                },

                startRecordingTimer() {
                    let seconds = 0;
                    this.recordingTimer = setInterval(() => {
                        seconds++;
                        const mins = Math.floor(seconds / 60);
                        const secs = seconds % 60;
                        this.recordingTime = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                    }, 1000);
                },

                stopRecordingTimer() {
                    if (this.recordingTimer) {
                        clearInterval(this.recordingTimer);
                        this.recordingTimer = null;
                    }
                },

                stopCamera(videoElement) {
                    const stream = videoElement.srcObject;
                    if (stream) {
                        const tracks = stream.getTracks();
                        tracks.forEach(track => track.stop());
                        videoElement.srcObject = null;
                    }
                    this.cameraActive = false;
                    this.videoActive = false;
                },

                // Step 4 Functions - NUEVO: Solo muestra resultados de los pasos anteriores
                async startVerification() {
                    console.log('📊 PASO 4: Mostrando resultado final de todos los pasos');
                    
                    this.verifying = true;
                    this.verificationProgress = 0;
                    const verificationStartTime = Date.now();
                    
                    try {
                        // Simular progreso para la animación
                        this.verificationStep = 'Recopilando resultados...';
                        this.verificationProgress = 30;
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        this.verificationStep = 'Procesando análisis completo...';
                        this.verificationProgress = 70;
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        this.verificationStep = 'Generando resultado final...';
                        this.verificationProgress = 100;
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Determinar éxito basado en los 3 pasos previos
                        const dniPassed = this.dniValidationPassed && this.step1Result?.success;
                        const selfiePassed = this.selfieVerificationPassed && this.step2Result?.success;
                        const livenessPassed = this.livenessVerificationPassed && this.step3Result?.success;
                        
                        const allStepsPassed = dniPassed && selfiePassed && livenessPassed;
                        
                        // Calcular confianza promedio de todos los pasos
                        let totalConfidence = 0;
                        let confidenceCount = 0;
                        
                        if (this.step1Result?.confidence) {
                            totalConfidence += this.step1Result.confidence;
                            confidenceCount++;
                        }
                        if (this.step2Result?.confidence) {
                            totalConfidence += this.step2Result.confidence;
                            confidenceCount++;
                        }
                        if (this.step3Result?.confidence) {
                            totalConfidence += this.step3Result.confidence;
                            confidenceCount++;
                        }
                        
                        const overallConfidence = confidenceCount > 0 ? Math.round(totalConfidence / confidenceCount) : 0;
                        
                        // Crear mensaje de error detallado
                        let errorMessage = '';
                        if (!allStepsPassed) {
                            const errors = [];
                            if (!dniPassed) errors.push('Validación de DNI falló');
                            if (!selfiePassed) errors.push('Verificación de selfie falló');
                            if (!livenessPassed) errors.push('Verificación de liveness falló');
                            errorMessage = `Fallos encontrados: ${errors.join(', ')}`;
                        }
                        
                        // Crear comparación de datos para mostrar (usar resultado del paso 1)
                        let dataComparison = null;
                        if (this.step1Result && this.step1Result.data_matches) {
                            dataComparison = {
                                name: { 
                                    input: `${this.userData.lastName}, ${this.userData.firstName}`, 
                                    extracted: this.step1Result.extracted_data?.name || 'No extraído', 
                                    match: this.step1Result.data_matches.name 
                                },
                                dni: { 
                                    input: this.userData.dni, 
                                    extracted: this.step1Result.extracted_data?.dni || 'No extraído', 
                                    match: this.step1Result.data_matches.dni 
                                },
                                birthDate: { 
                                    input: this.userData.birthDate, 
                                    extracted: this.step1Result.extracted_data?.birthdate || 'No extraído', 
                                    match: this.step1Result.data_matches.birthdate 
                                },
                                address: { 
                                    input: this.userData.address, 
                                    extracted: this.step1Result.extracted_data?.address || 'No extraído', 
                                    match: this.step1Result.data_matches.address 
                                },
                                matchCount: Object.values(this.step1Result.data_matches).filter(Boolean).length,
                                totalFields: 4,
                                overallMatch: this.step1Result.recommendation !== 'REJECT',
                                summary: this.step1Result.details || `Confianza: ${this.step1Result.confidence}%`
                            };
                        }
                        
                        // Establecer texto extraído del paso 1
                        if (this.step1Result?.extracted_text) {
                            this.extractedText = this.step1Result.extracted_text;
                        }
                        
                        // Resultado final
                        this.verificationResult = {
                            success: allStepsPassed,
                            message: allStepsPassed ? 
                                'Su identidad ha sido verificada exitosamente' : 
                                errorMessage,
                            dniMatch: selfiePassed,  // DNI vs Selfie del paso 2
                            videoMatch: livenessPassed,  // Selfie vs Video del paso 3
                            dataExtracted: dniPassed,  // Extracción de datos del paso 1
                            
                            // NUEVOS: Datos del paso 1 (document validation)
                            document_analysis: this.step1Result?.document_analysis || {},
                            data_matches: this.step1Result?.data_matches || {},
                            extracted_data: this.step1Result?.extracted_data || {},
                            extracted_text: this.step1Result?.extracted_text || this.extractedText || '',
                            details: this.step1Result?.details || 'Verificación completada',
                            
                            dataComparison,
                            overallConfidence,
                            debugInfo: {
                                step1Result: this.step1Result,
                                step2Result: this.step2Result,
                                step3Result: this.step3Result,
                                stepsStatus: `DNI: ${dniPassed ? '✓' : '✗'}, Selfie: ${selfiePassed ? '✓' : '✗'}, Liveness: ${livenessPassed ? '✓' : '✗'}`,
                                processingTime: Date.now() - verificationStartTime
                            }
                        };
                        
                        console.log('📊 Resultado final compilado:', this.verificationResult);
                        
                    } catch (error) {
                        console.error('❌ Error compilando resultado final:', error);
                        
                        this.verificationResult = {
                            success: false,
                            message: 'Error procesando resultados finales: ' + error.message,
                            dniMatch: false,
                            videoMatch: false,
                            dataExtracted: false,
                            dataComparison: null,
                            overallConfidence: 0,
                            debugInfo: {
                                error: error.message,
                                processingTime: Date.now() - verificationStartTime
                            }
                        };
                    } finally {
                        this.verifying = false;
                        this.verificationComplete = true;
                    }
                },

                restartVerification() {
                    this.currentStep = 1;
                    this.verifying = false;
                    this.verificationComplete = false;
                    this.verificationProgress = 0;
                    
                    // Reset all data
                    this.userData = { 
                        firstName: '', 
                        lastName: '', 
                        dni: '', 
                        sex: '',
                        birthDate: '', 
                        nationality: 'ESP',
                        address: '' 
                    };
                    this.dniPhotoFile = null;
                    this.dniPhotoPreview = null;
                    this.dniPhotoPath = null;
                    this.extractedText = '';
                    
                    // Reset GPT-4 analysis (legacy)
                    this.gptVerification = null;
                    this.gptExtractedData = null;
                    this.gptDetails = '';
                    
                    // NUEVO: Reset step-by-step verification results
                    this.dniValidationPassed = false;
                    this.selfieVerificationPassed = false;
                    this.livenessVerificationPassed = false;
                    this.step1Result = null;
                    this.step2Result = null;
                    this.step3Result = null;
                    
                    this.selfiePhoto = null;
                    this.recordedVideo = null;
                    
                    // Reset liveness detection
                    this.currentInstruction = null;
                    this.currentInstructionIndex = 0;
                    this.instructionProgress = 0;
                    if (this.instructionTimer) {
                        clearInterval(this.instructionTimer);
                    }
                },

                // NUEVO: Funciones de utilidad para mostrar mensajes
                showSuccess(message) {
                    console.log('✅ Éxito:', message);
                    this.errorMessage = ''; // Limpiar errores previos
                    // Mostrar notificación de éxito temporal (opcional)
                    // TODO: Implementar notificación de éxito visual si se desea
                },

                showError(message) {
                    console.error('❌ Error:', message);
                    this.errorMessage = message;
                    // Auto-ocultar después de 8 segundos
                    setTimeout(() => {
                        this.errorMessage = '';
                    }, 8000);
                },

                createDataComparison() {
                    if (!this.extractedText) {
                        return {
                            name: { input: 'N/A', extracted: 'Sin datos', match: false },
                            dni: { input: 'N/A', extracted: 'Sin datos', match: false },
                            birthDate: { input: 'N/A', extracted: 'Sin datos', match: false },
                            address: { input: 'N/A', extracted: 'Sin datos', match: false },
                            matchCount: 0,
                            totalFields: 4,
                            overallMatch: false,
                            summary: 'No se pudieron extraer datos del DNI para comparar'
                        };
                    }

                    const extractedText = this.extractedText.toUpperCase();
                    
                    // Extract data from OCR text
                    const extractedData = {
                        name: this.extractNameFromOCR(extractedText),
                        dni: this.extractDNIFromOCR(extractedText),
                        birthDate: this.extractBirthDateFromOCR(extractedText),
                        address: this.extractAddressFromOCR(extractedText)
                    };

                    // User input data (formatted for comparison)
                    const inputData = {
                        name: `${this.userData.lastName}, ${this.userData.firstName}`.toUpperCase(),
                        dni: this.userData.dni.toUpperCase(),
                        birthDate: this.formatBirthDate(this.userData.birthDate),
                        address: this.userData.address.toUpperCase()
                    };

                    // Compare each field
                    const comparison = {
                        name: {
                            input: inputData.name,
                            extracted: extractedData.name,
                            match: this.compareNames(inputData.name, extractedData.name)
                        },
                        dni: {
                            input: inputData.dni,
                            extracted: extractedData.dni,
                            match: this.compareDNI(inputData.dni, extractedData.dni)
                        },
                        birthDate: {
                            input: inputData.birthDate,
                            extracted: extractedData.birthDate,
                            match: this.compareBirthDate(inputData.birthDate, extractedData.birthDate)
                        },
                        address: {
                            input: inputData.address,
                            extracted: extractedData.address,
                            match: this.compareAddress(inputData.address, extractedData.address)
                        }
                    };

                    // Calculate overall match
                    const matches = Object.values(comparison).filter(field => field.match);
                    const matchCount = matches.length;
                    const totalFields = 4;
                    const overallMatch = matchCount >= 3; // At least 3 out of 4 fields must match

                    return {
                        ...comparison,
                        matchCount,
                        totalFields,
                        overallMatch,
                        summary: overallMatch ? 
                            `Excelente: ${matchCount} de ${totalFields} campos coinciden` :
                            `Problema: Solo ${matchCount} de ${totalFields} campos coinciden`
                    };
                },

                extractNameFromOCR(text) {
                    // Look for name patterns in Spanish DNI
                    const lines = text.split(/\n|\r/);
                    let apellidos = '';
                    let nombre = '';
                    
                    // Find apellidos (usually before NOMBRE/NOM line)
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        
                        // Skip empty lines and lines with numbers/symbols
                        if (!line || /\d/.test(line) || /[~®©]/.test(line) || line.length < 3) continue;
                        
                        // Check if next line contains NOMBRE
                        const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';
                        if (nextLine.includes('NOMBRE') || nextLine.includes('NOM')) {
                            apellidos = line;
                            break;
                        }
                        
                        // Also check if this looks like a surname (all caps, no special chars)
                        if (/^[A-ZÁÉÍÓÚÑ\s]+$/.test(line) && line.length > 2 && line.length < 30) {
                            // Check if it's not a common DNI word
                            if (!line.includes('REINO') && !line.includes('ESPANA') && !line.includes('SEXO') && 
                                !line.includes('NACIONALIDAD') && !line.includes('IDENTITY')) {
                                apellidos = line;
                            }
                        }
                    }
                    
                    // Find nombre (usually after NOMBRE/NOM line)
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line.includes('NOMBRE') || line.includes('NOM')) {
                            // Check next line for the actual name
                            const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';
                            if (nextLine && /^[A-ZÁÉÍÓÚÑ\s]+$/.test(nextLine) && nextLine.length > 1 && nextLine.length < 20) {
                                nombre = nextLine;
                                break;
                            }
                        }
                    }
                    
                    if (apellidos && nombre) {
                        return `${apellidos}, ${nombre}`;
                    } else if (apellidos) {
                        return apellidos;
                    } else if (nombre) {
                        return nombre;
                    }
                    
                    return 'No encontrado en DNI';
                },

                extractDNIFromOCR(text) {
                    // Look for DNI number patterns in Spanish DNI
                    const dniPatterns = [
                        /(\d{8}[A-Z])/g,  // 12345678X (most common)
                        /(\d{8}\s*[A-Z])/g,  // 12345678 X (with space)
                        /[^\d]*(\d{8})[^\d\s]*([A-Z])/g,  // ~12345678GE® (with junk around)
                        /DNI[:\s]*(\d{8}[A-Z])/g,
                        /(\d{8}-[A-Z])/g  // 12345678-X
                    ];
                    
                    for (const pattern of dniPatterns) {
                        let match;
                        while ((match = pattern.exec(text)) !== null) {
                            if (match[1] && match[2]) {
                                // Pattern with separated numbers and letter
                                const dni = match[1] + match[2];
                                if (dni.length === 9) return dni;
                            } else if (match[1]) {
                                // Pattern with combined number and letter
                                const dni = match[1].replace(/[-\s]/g, '');
                                if (dni.length === 9 && /^\d{8}[A-Z]$/.test(dni)) {
                                    return dni;
                                }
                            }
                        }
                        pattern.lastIndex = 0; // Reset regex
                    }
                    
                    // Try to find 8 digits followed by a letter anywhere in text
                    const fallbackMatch = text.match(/(\d{8})[^\d]*([A-Z])/);
                    if (fallbackMatch) {
                        return fallbackMatch[1] + fallbackMatch[2];
                    }
                    
                    return 'No encontrado en DNI';
                },

                extractBirthDateFromOCR(text) {
                    // Look for birth date patterns in Spanish DNI
                    const datePatterns = [
                        /NACIMIENTO[:\s\/]*(\d{2}[\s\/\-]\d{2}[\s\/\-]\d{4})/i,  // NACIMIENTO 06 03 1994
                        /NAIXEMENT[:\s\/]*(\d{2}[\s\/\-]\d{2}[\s\/\-]\d{4})/i,   // Catalan version
                        /(\d{2}\s+\d{2}\s+\d{4})/g,  // 06 03 1994 (spaces)
                        /(\d{2}[\/\-]\d{2}[\/\-]\d{4})/g,  // 06/03/1994 or 06-03-1994
                        /(\d{1,2}\s+\d{1,2}\s+\d{4})/g  // 6 3 1994 (single digits)
                    ];
                    
                    for (const pattern of datePatterns) {
                        let match;
                        if (pattern.global) {
                            while ((match = pattern.exec(text)) !== null) {
                                let dateStr = match[1];
                                // Normalize date format
                                dateStr = dateStr.replace(/\s+/g, '/').replace(/-/g, '/');
                                
                                // Validate it looks like a reasonable birth date
                                const parts = dateStr.split('/');
                                if (parts.length === 3) {
                                    const day = parseInt(parts[0]);
                                    const month = parseInt(parts[1]);
                                    const year = parseInt(parts[2]);
                                    
                                    // Basic validation: reasonable birth year and valid day/month ranges
                                    if (year >= 1920 && year <= 2010 && 
                                        day >= 1 && day <= 31 && 
                                        month >= 1 && month <= 12) {
                                        return dateStr;
                                    }
                                }
                            }
                            pattern.lastIndex = 0; // Reset regex
                        } else {
                            match = text.match(pattern);
                            if (match) {
                                let dateStr = match[1];
                                dateStr = dateStr.replace(/\s+/g, '/').replace(/-/g, '/');
                                return dateStr;
                            }
                        }
                    }
                    
                    return 'No encontrado en DNI';
                },

                extractAddressFromOCR(text) {
                    // Look for address patterns in Spanish DNI
                    const addressPatterns = [
                        /DOMICILIO[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓN|VALIDEZ|$)/i,
                        /DIRECCIÓN[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓN|VALIDEZ|$)/i,
                        /DIRECCIÓ[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓ|VALIDESA|$)/i,  // Catalan
                        /CALLE[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓN|VALIDEZ|$)/i,
                        /CARRER[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓ|VALIDESA|$)/i,  // Catalan
                        /AVENIDA[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓN|VALIDEZ|$)/i,
                        /PLAZA[:\s]*([A-ZÁÉÍÓÚÑ0-9\s,.-]+?)(?=\n|\r|FECHA|EXPEDICIÓN|VALIDEZ|$)/i
                    ];
                    
                    for (const pattern of addressPatterns) {
                        const match = text.match(pattern);
                        if (match && match[1]) {
                            const address = match[1].trim();
                            // Filter out very short or obviously wrong matches
                            if (address.length > 5 && !address.includes('FECHA') && !address.includes('EXPEDICIÓN')) {
                                return address;
                            }
                        }
                    }
                    
                    // Some DNI don't show full address, look for patterns like street names
                    const lines = text.split(/\n|\r/);
                    for (const line of lines) {
                        const trimmed = line.trim();
                        // Look for lines that might be addresses (contain numbers and letters, reasonable length)
                        if (/^[A-ZÁÉÍÓÚÑ\s]+\s+\d+/.test(trimmed) && trimmed.length > 10 && trimmed.length < 60) {
                            // Make sure it's not a date or DNI number
                            if (!/\d{8}/.test(trimmed) && !/\d{2}\s+\d{2}\s+\d{4}/.test(trimmed)) {
                                return trimmed;
                            }
                        }
                    }
                    
                    return 'No encontrado en DNI';
                },

                formatBirthDate(dateString) {
                    if (!dateString) return 'No proporcionado';
                    
                    try {
                        const date = new Date(dateString);
                        const day = date.getDate().toString().padStart(2, '0');
                        const month = (date.getMonth() + 1).toString().padStart(2, '0');
                        const year = date.getFullYear();
                        return `${day}/${month}/${year}`;
                    } catch {
                        return dateString;
                    }
                },

                compareNames(input, extracted) {
                    if (!input || !extracted || extracted === 'No encontrado en DNI') return false;
                    
                    // Remove special characters and extra spaces
                    const cleanInput = input.replace(/[^A-ZÁÉÍÓÚÑ\s]/g, '').replace(/\s+/g, ' ').trim().toUpperCase();
                    const cleanExtracted = extracted.replace(/[^A-ZÁÉÍÓÚÑ\s]/g, '').replace(/\s+/g, ' ').trim().toUpperCase();
                    
                    // Split names into parts
                    const inputParts = cleanInput.split(/[,\s]+/).filter(part => part.length > 1);
                    const extractedParts = cleanExtracted.split(/[,\s]+/).filter(part => part.length > 1);
                    
                    // Check if there's significant overlap between name parts
                    let matches = 0;
                    for (const inputPart of inputParts) {
                        for (const extractedPart of extractedParts) {
                            if (inputPart === extractedPart || 
                                inputPart.includes(extractedPart) || 
                                extractedPart.includes(inputPart) ||
                                this.calculateSimilarity(inputPart, extractedPart) > 0.85) {
                                matches++;
                                break;
                            }
                        }
                    }
                    
                    // Consider it a match if at least 50% of the input parts have a match
                    const matchRatio = matches / Math.max(inputParts.length, 1);
                    
                    // Also check direct similarity as fallback
                    const directSimilarity = this.calculateSimilarity(cleanInput, cleanExtracted);
                    
                    return matchRatio >= 0.5 || directSimilarity > 0.7;
                },

                compareDNI(input, extracted) {
                    if (!input || !extracted || extracted === 'No encontrado en DNI') return false;
                    
                    const cleanInput = input.replace(/[^0-9A-Z]/g, '').toUpperCase();
                    const cleanExtracted = extracted.replace(/[^0-9A-Z]/g, '').toUpperCase();
                    
                    // Exact match is preferred
                    if (cleanInput === cleanExtracted) return true;
                    
                    // If both are 9 characters (8 digits + letter), check similarity
                    if (cleanInput.length === 9 && cleanExtracted.length === 9) {
                        // Check if the letter matches (most important part)
                        const inputLetter = cleanInput.slice(-1);
                        const extractedLetter = cleanExtracted.slice(-1);
                        
                        // Check if the numbers are similar (allow 1-2 character differences for OCR errors)
                        const inputNumbers = cleanInput.slice(0, 8);
                        const extractedNumbers = cleanExtracted.slice(0, 8);
                        
                        const numberSimilarity = this.calculateSimilarity(inputNumbers, extractedNumbers);
                        
                        // Accept if letter matches and numbers are very similar (>87.5% = max 1 digit different)
                        return inputLetter === extractedLetter && numberSimilarity >= 0.875;
                    }
                    
                    // For other cases, check if one contains the other (partial matches)
                    return cleanInput.includes(cleanExtracted) || cleanExtracted.includes(cleanInput);
                },

                compareBirthDate(input, extracted) {
                    if (!input || !extracted || extracted === 'No encontrado en DNI') return false;
                    
                    // Normalize date formats
                    const normalizeDate = (date) => {
                        return date.replace(/[-\s]/g, '/').replace(/\/+/g, '/');
                    };
                    
                    const normalizedInput = normalizeDate(input);
                    const normalizedExtracted = normalizeDate(extracted);
                    
                    // Direct match
                    if (normalizedInput === normalizedExtracted) return true;
                    
                    // Parse dates to compare components
                    const parseDate = (dateStr) => {
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            return {
                                day: parseInt(parts[0]),
                                month: parseInt(parts[1]),
                                year: parseInt(parts[2])
                            };
                        }
                        return null;
                    };
                    
                    const inputDate = parseDate(normalizedInput);
                    const extractedDate = parseDate(normalizedExtracted);
                    
                    // Compare individual components (allows for minor OCR errors)
                    if (inputDate && extractedDate) {
                        return inputDate.day === extractedDate.day &&
                               inputDate.month === extractedDate.month &&
                               inputDate.year === extractedDate.year;
                    }
                    
                    // Fallback: check if the strings are very similar
                    return this.calculateSimilarity(normalizedInput, normalizedExtracted) > 0.9;
                },

                compareAddress(input, extracted) {
                    if (!input || !extracted || extracted === 'No encontrado en DNI') return false;
                    
                    // For address, we use similarity matching since OCR might not be perfect
                    const cleanInput = input.replace(/[^A-ZÁÉÍÓÚÑ0-9\s]/g, '').replace(/\s+/g, ' ').trim();
                    const cleanExtracted = extracted.replace(/[^A-ZÁÉÍÓÚÑ0-9\s]/g, '').replace(/\s+/g, ' ').trim();
                    
                    return this.calculateSimilarity(cleanInput, cleanExtracted) > 0.6; // 60% similarity
                },

                calculateSimilarity(str1, str2) {
                    if (str1.length === 0 && str2.length === 0) return 1;
                    if (str1.length === 0 || str2.length === 0) return 0;
                    
                    const longer = str1.length > str2.length ? str1 : str2;
                    const shorter = str1.length > str2.length ? str2 : str1;
                    
                    if (longer.length === 0) return 1;
                    
                    const distance = this.levenshteinDistance(longer, shorter);
                    return (longer.length - distance) / longer.length;
                },

                levenshteinDistance(str1, str2) {
                    const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
                    
                    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
                    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
                    
                    for (let j = 1; j <= str2.length; j++) {
                        for (let i = 1; i <= str1.length; i++) {
                            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                            matrix[j][i] = Math.min(
                                matrix[j][i - 1] + 1,
                                matrix[j - 1][i] + 1,
                                matrix[j - 1][i - 1] + cost
                            );
                        }
                    }
                    
                    return matrix[str2.length][str1.length];
                },

                showError(message) {
                    this.errorMessage = message;
                    setTimeout(() => this.errorMessage = '', 5000);
                },

                // Utility function to convert data URL to File
                dataURLtoFile(dataurl, filename) {
                    if (!dataurl) return null;
                    
                    // Note: blob URLs are handled separately in async context
                    if (dataurl.startsWith('blob:')) {
                        throw new Error('Blob URLs should be handled asynchronously');
                    }
                    
                    // Handle data URLs (for images)
                    try {
                        const arr = dataurl.split(',');
                        const mime = arr[0].match(/:(.*?);/)[1];
                        const bstr = atob(arr[1]);
                        let n = bstr.length;
                        const u8arr = new Uint8Array(n);
                        while (n--) {
                            u8arr[n] = bstr.charCodeAt(n);
                        }
                        return new File([u8arr], filename, { type: mime });
                    } catch (error) {
                        console.error('Error converting dataURL to File:', error);
                        return null;
                    }
                },
                
                // Utility function for delays
                delay(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                },

                // ================================
                // FUNCIONES DE DETECCIÓN ESPECÍFICAS REALES
                // ================================

                // Analizar frame de video en tiempo real
                analyzeVideoFrame() {
                    if (!this.videoElement || this.videoElement.videoWidth === 0) {
                        return null;
                    }

                    try {
                        // Usar FaceDetectionUtils para análisis real
                        const faceData = window.FaceDetectionUtils.detectFaceMovement(this.videoElement);
                        
                        if (faceData && faceData.faceDetected) {
                            // Establecer datos base si es la primera detección
                            if (!this.baselineFaceData) {
                                this.baselineFaceData = { 
                                    ...faceData,
                                    timestamp: Date.now()
                                };
                                console.log('🎯 Baseline facial data establecido:', this.baselineFaceData);
                            }
                            
                            // Detectar movimientos basados en la instrucción actual
                            this.detectInstructionMovement(faceData);
                            
                            // Guardar datos para comparación
                            this.previousFaceData = this.currentFaceData;
                            this.currentFaceData = faceData;
                            
                            // Mantener historial de movimientos (reducido para mejor rendimiento)
                            this.faceHistory.push({
                                ...faceData,
                                timestamp: Date.now()
                            });
                            if (this.faceHistory.length > 20) { // Reducido de 30 a 20
                                this.faceHistory.shift();
                            }
                        } else if (faceData) {
                            // Hay datos pero rostro no es claro - mantener referencia pero no procesar movimientos
                            this.currentFaceData = faceData;
                        }
                        
                        return faceData;
                    } catch (error) {
                        console.warn('Error analizando frame:', error);
                        return null;
                    }
                },

                // Detectar movimientos específicos según la instrucción actual - VALIDACIÓN MUY ESTRICTA
                detectInstructionMovement(faceData) {
                    if (!this.currentInstruction || !this.baselineFaceData) return;
                    
                    const instruction = this.currentInstruction;
                    const validation = this.instructionValidation[instruction.type];
                    const currentTime = Date.now();
                    
                    let movementDetected = false;
                    let movementStrength = 0;
                    let positioningCorrect = false; // Nueva variable para posicionamiento
                    
                    switch (instruction.type) {
                        case 'lookAtCamera':
                            const result1 = this.detectCenterGaze(faceData);
                            movementDetected = result1.detected;
                            movementStrength = result1.strength;
                            positioningCorrect = result1.positioning; // Nuevo campo
                            break;
                            
                        case 'headTurn':
                            const result2 = this.detectHeadTurn(faceData);
                            movementDetected = result2.detected;
                            movementStrength = result2.strength;
                            positioningCorrect = result2.positioning;
                            break;
                            
                        case 'headNod':
                            const result3 = this.detectHeadNod(faceData);
                            movementDetected = result3.detected;
                            movementStrength = result3.strength;
                            positioningCorrect = result3.positioning;
                            break;
                            
                        case 'headShake':
                            const result4 = this.detectHeadShake(faceData);
                            movementDetected = result4.detected;
                            movementStrength = result4.strength;
                            positioningCorrect = result4.positioning;
                            break;
                            
                        case 'smile':
                            const result5 = this.detectSmile(faceData);
                            movementDetected = result5.detected;
                            movementStrength = result5.strength;
                            positioningCorrect = result5.positioning;
                            break;
                            
                        case 'blink':
                            const result6 = this.detectBlink(faceData);
                            movementDetected = result6.detected;
                            movementStrength = result6.strength;
                            positioningCorrect = result6.positioning;
                            break;
                    }
                    
                    // ⭐ VALIDACIÓN MUY ESTRICTA: Solo cuenta si está bien posicionado Y hace el movimiento
                    const validDetection = movementDetected && positioningCorrect && movementStrength > 0.6; // Umbral aún más alto
                    
                    if (validDetection) {
                        // Inicializar detección si no está activa
                        if (!validation.isDetecting) {
                            validation.isDetecting = true;
                            validation.movementStart = currentTime;
                            validation.timeValidating = 0;
                            validation.progress = 0; // Reset progreso al iniciar
                            console.log(`🎯 ¡INICIANDO validación ESTRICTA: ${instruction.type}! (fuerza: ${movementStrength.toFixed(2)})`);
                        }
                        
                        // ⭐ SOLO ACUMULAR TIEMPO SI LA DETECCIÓN ES VÁLIDA
                        validation.lastDetection = currentTime;
                        validation.timeValidating = currentTime - validation.movementStart;
                        
                        // Progreso SOLO basado en tiempo de validación REAL (sin bonus de fuerza)
                        validation.progress = Math.min(100, (validation.timeValidating / validation.requiredDuration) * 100);
                        
                        // ⭐ COMPLETAR SOLO CUANDO SE ALCANCEN LOS 5 SEGUNDOS COMPLETOS DE DETECCIÓN VÁLIDA
                        if (validation.timeValidating >= validation.requiredDuration && !validation.completed) {
                            validation.validationPassed = true;
                            validation.completed = true;
                            validation.progress = 100;
                            
                            console.log(`✅ ¡COMPLETADO tras ${validation.timeValidating/1000}s de validación CONTINUA: ${instruction.type}!`);
                            this.completeCurrentInstructionStrict();
                            return; // Salir inmediatamente al completar
                        }
                        
                        // Feedback positivo con tiempo restante
                        const timeRemaining = Math.max(0, validation.requiredDuration - validation.timeValidating);
                        this.updateRealTimeFeedbackStrict(instruction.type, validation.progress, movementStrength, timeRemaining);
                        
                    } else {
                        // ⭐ REINICIO INMEDIATO si no hay detección válida
                        if (validation.isDetecting) {
                            console.log(`⚠️ REINICIO INMEDIATO ${instruction.type} - Posicionamiento: ${positioningCorrect}, Movimiento: ${movementDetected}, Fuerza: ${movementStrength.toFixed(2)}`);
                            
                            // RESET COMPLETO Y INMEDIATO
                            validation.isDetecting = false;
                            validation.movementStart = null;
                            validation.timeValidating = 0;
                            validation.progress = 0; // Reset completo a 0
                            validation.validationPassed = false;
                            
                            // Feedback específico según el problema
                            if (!positioningCorrect) {
                                this.realTimeFeedback = `❌ Posiciónate correctamente - ${instruction.title}`;
                            } else if (!movementDetected) {
                                this.realTimeFeedback = `❌ Haz el movimiento - ${instruction.title}`;
                            } else {
                                this.realTimeFeedback = `❌ Movimiento más claro - ${instruction.title}`;
                            }
                        } else {
                            // Feedback inicial si no está detectando
                            this.realTimeFeedback = `🎯 Prepárate: ${instruction.title} durante 5 segundos`;
                        }
                    }
                },

                // Detectar mirada al centro - CON VALIDACIÓN DE POSICIONAMIENTO
                detectCenterGaze(faceData) {
                    const validation = this.instructionValidation.lookAtCamera;
                    const centerScore = faceData.regions.center;
                    const balance = Math.abs(faceData.regions.left - faceData.regions.right);
                    const overallBrightness = faceData.brightness;
                    
                    // Validar posicionamiento: rostro visible y centrado
                    const positioningCorrect = overallBrightness > 50 && centerScore > 60 && balance < 30;
                    
                    // Detectar mirada al centro: muy estricto
                    const gazeDetected = centerScore > 90 && balance < 15 && overallBrightness > 70;
                    
                    validation.centeringScore = Math.max(validation.centeringScore, centerScore);
                    
                    return {
                        detected: gazeDetected,
                        strength: Math.min(1, centerScore / 100),
                        positioning: positioningCorrect  // Nueva propiedad
                    };
                },

                // Detectar giro de cabeza - CON VALIDACIÓN DE POSICIONAMIENTO
                detectHeadTurn(faceData) {
                    const validation = this.instructionValidation.headTurn;
                    const horizontalMovement = faceData.movement.horizontal;
                    const overallBrightness = faceData.brightness;
                    
                    // Validar posicionamiento: rostro visible
                    const positioningCorrect = overallBrightness > 45 && faceData.regions.center > 50;
                    
                    // Detectar giros a izquierda y derecha
                    if (horizontalMovement > this.movementThresholds.horizontal) {
                        validation.rightAngle = Math.max(validation.rightAngle, horizontalMovement);
                    } else if (horizontalMovement < -this.movementThresholds.horizontal) {
                        validation.leftAngle = Math.max(validation.leftAngle, Math.abs(horizontalMovement));
                    }
                    
                    validation.maxAngle = Math.max(validation.leftAngle, validation.rightAngle);
                    
                    // Se requiere movimiento significativo en ambas direcciones
                    const bothDirections = validation.leftAngle > 20 && validation.rightAngle > 20; // Más estricto
                    
                    return {
                        detected: bothDirections,
                        strength: Math.min(1, validation.maxAngle / 35), // Más estricto
                        positioning: positioningCorrect
                    };
                },

                // Detectar asentir con la cabeza - CON VALIDACIÓN DE POSICIONAMIENTO
                detectHeadNod(faceData) {
                    const validation = this.instructionValidation.headNod;
                    const verticalMovement = faceData.movement.vertical;
                    const overallBrightness = faceData.brightness;
                    
                    // Validar posicionamiento: rostro visible
                    const positioningCorrect = overallBrightness > 45 && faceData.regions.center > 50;
                    
                    // Detectar movimientos arriba y abajo
                    if (verticalMovement > this.movementThresholds.vertical) {
                        validation.downMovement = Math.max(validation.downMovement, verticalMovement);
                    } else if (verticalMovement < -this.movementThresholds.vertical) {
                        validation.upMovement = Math.max(validation.upMovement, Math.abs(verticalMovement));
                    }
                    
                    validation.totalMovement = validation.upMovement + validation.downMovement;
                    
                    // Se requiere movimiento en ambas direcciones - más estricto
                    const bothDirections = validation.upMovement > 12 && validation.downMovement > 12;
                    
                    return {
                        detected: bothDirections,
                        strength: Math.min(1, validation.totalMovement / 25),
                        positioning: positioningCorrect
                    };
                },

                // Detectar negar con la cabeza - CON VALIDACIÓN DE POSICIONAMIENTO
                detectHeadShake(faceData) {
                    const validation = this.instructionValidation.headShake;
                    const horizontalMovement = faceData.movement.horizontal;
                    const overallBrightness = faceData.brightness;
                    
                    // Validar posicionamiento: rostro visible
                    const positioningCorrect = overallBrightness > 45 && faceData.regions.center > 50;
                    
                    // Similar a headTurn pero con movimiento rápido
                    if (horizontalMovement > this.movementThresholds.horizontal) {
                        validation.rightMovement = Math.max(validation.rightMovement, horizontalMovement);
                    } else if (horizontalMovement < -this.movementThresholds.horizontal) {
                        validation.leftMovement = Math.max(validation.leftMovement, Math.abs(horizontalMovement));
                    }
                    
                    validation.totalMovement = validation.leftMovement + validation.rightMovement;
                    
                    // Requiere movimiento rápido en ambas direcciones - más estricto
                    const rapidMovement = validation.leftMovement > 15 && validation.rightMovement > 15;
                    
                    return {
                        detected: rapidMovement,
                        strength: Math.min(1, validation.totalMovement / 30),
                        positioning: positioningCorrect
                    };
                },

                // Detectar sonrisa - CON VALIDACIÓN DE POSICIONAMIENTO
                detectSmile(faceData) {
                    const validation = this.instructionValidation.smile;
                    const mouthBrightness = faceData.regions.mouth;
                    const baselineMouth = this.baselineFaceData.regions.mouth;
                    const overallBrightness = faceData.brightness;
                    
                    // Validar posicionamiento: rostro visible y centrado
                    const positioningCorrect = overallBrightness > 50 && faceData.regions.center > 60;
                    
                    // Detectar cambio en zona de boca (sonrisa aumenta brillo) - más estricto
                    const mouthChange = mouthBrightness - baselineMouth;
                    
                    if (mouthChange > this.movementThresholds.smile * 2) { // Más estricto
                        validation.smileDetected = true;
                        validation.smileDuration += 200; // Incrementar duración de sonrisa
                    } else {
                        validation.smileDetected = false;
                    }
                    
                    return {
                        detected: validation.smileDetected && validation.smileDuration > 1000, // Requiere sonrisa mantenida
                        strength: Math.min(1, Math.max(0, mouthChange / 25)),
                        positioning: positioningCorrect
                    };
                },

                // Detectar parpadeo - CON VALIDACIÓN DE POSICIONAMIENTO
                detectBlink(faceData) {
                    const validation = this.instructionValidation.blink;
                    const overallBrightness = faceData.brightness;
                    const previousBrightness = this.previousFaceData ? this.previousFaceData.brightness : overallBrightness;
                    
                    // Validar posicionamiento: rostro visible
                    const positioningCorrect = overallBrightness > 40 && faceData.regions.center > 50;
                    
                    // Detectar caída súbita en brillo (parpadeo) - más estricto
                    const brightnessChange = previousBrightness - overallBrightness;
                    
                    if (brightnessChange > this.movementThresholds.blink * 1.5 && !validation.isBlinking) { // Más estricto
                        validation.isBlinking = true;
                        validation.blinkCount++;
                        validation.lastBlink = Date.now();
                        console.log(`👁️ Parpadeo detectado #${validation.blinkCount} (cambio: ${brightnessChange.toFixed(1)})`);
                        
                        // Reset estado de parpadeo después de 400ms
                        setTimeout(() => {
                            validation.isBlinking = false;
                        }, 400);
                    }
                    
                    return {
                        detected: validation.blinkCount >= 3, // Requiere 3 parpadeos claros
                        strength: Math.min(1, validation.blinkCount / 3),
                        positioning: positioningCorrect
                    };
                },

                // Actualizar feedback en tiempo real - NUEVA VERSIÓN ESTRICTA
                updateRealTimeFeedbackStrict(instructionType, progress, strength, timeRemaining) {
                    const secondsRemaining = Math.ceil(timeRemaining / 1000);
                    const progressPercent = Math.round(progress);
                    
                    let baseMessage = '';
                    let statusIcon = '';
                    
                    switch (instructionType) {
                        case 'lookAtCamera':
                            baseMessage = 'Mantén la mirada al centro';
                            statusIcon = '👀';
                            break;
                        case 'headTurn':
                            baseMessage = 'Girando cabeza correctamente';
                            statusIcon = '🔄';
                            break;
                        case 'headNod':
                            baseMessage = 'Asintiendo correctamente';
                            statusIcon = '↕️';
                            break;
                        case 'headShake':
                            baseMessage = 'Negando correctamente';
                            statusIcon = '↔️';
                            break;
                        case 'smile':
                            baseMessage = 'Manteniendo sonrisa';
                            statusIcon = '😊';
                            break;
                        case 'blink':
                            baseMessage = 'Parpadeando correctamente';
                            statusIcon = '👁️';
                            break;
                        default:
                            baseMessage = 'Movimiento detectado';
                            statusIcon = '✅';
                    }
                    
                    // Mensaje con tiempo restante y progreso
                    if (timeRemaining > 0) {
                        this.realTimeFeedback = `${statusIcon} ${baseMessage} - ${secondsRemaining}s restantes (${progressPercent}%)`;
                    } else {
                        this.realTimeFeedback = `${statusIcon} ${baseMessage} - ¡Completando! (${progressPercent}%)`;
                    }
                },

                // NUEVA: Completar instrucción con validación estricta
                completeCurrentInstructionStrict() {
                    const instruction = this.currentInstruction;
                    const validation = this.instructionValidation[instruction.type];
                    
                    console.log(`✅ ¡INSTRUCCIÓN COMPLETADA EXITOSAMENTE!: ${instruction.type}`);
                    console.log(`   - Tiempo validado: ${validation.timeValidating/1000}s`);
                    console.log(`   - Progreso final: ${validation.progress}%`);
                    
                    // Mostrar mensaje de éxito con tiempo
                    this.realTimeFeedback = `✅ ¡${instruction.title} completado! (${Math.round(validation.timeValidating/1000)}s)`;
                    
                    // Pausa de 2 segundos antes de continuar (para que el usuario vea el éxito)
                    setTimeout(() => {
                        this.currentInstructionIndex++;
                        if (this.currentInstructionIndex >= this.livenessInstructions.length) {
                            // Todas las instrucciones completadas - COMPARAR CON SELFIE
                            this.completeLivenessWithComparison();
                        } else {
                            // Siguiente instrucción
                            this.startNextInstructionStrict();
                        }
                    }, 2000);
                },

                // NUEVA: Iniciar siguiente instrucción con reset completo
                startNextInstructionStrict() {
                    if (this.currentInstructionIndex >= this.livenessInstructions.length) {
                        this.completeLivenessWithComparison();
                        return;
                    }

                    const instruction = this.livenessInstructions[this.currentInstructionIndex];
                    this.currentInstruction = instruction;
                    this.instructionProgress = 0;
                    this.instructionStartTime = Date.now();
                    
                    // Reset COMPLETO de validación para esta instrucción
                    const validation = this.instructionValidation[instruction.type];
                    validation.completed = false;
                    validation.progress = 0;
                    validation.isDetecting = false;
                    validation.lastDetection = Date.now();
                    validation.movementStart = null;
                    validation.validationPassed = false;
                    validation.timeValidating = 0;
                    
                    // Reset específico por tipo de movimiento
                    switch (instruction.type) {
                        case 'lookAtCamera':
                            validation.centeringScore = 0;
                            break;
                        case 'headTurn':
                            validation.leftAngle = 0;
                            validation.rightAngle = 0;
                            validation.maxAngle = 0;
                            break;
                        case 'headNod':
                            validation.upMovement = 0;
                            validation.downMovement = 0;
                            validation.totalMovement = 0;
                            break;
                        case 'headShake':
                            validation.leftMovement = 0;
                            validation.rightMovement = 0;
                            validation.totalMovement = 0;
                            break;
                        case 'smile':
                            validation.smileDetected = false;
                            validation.smileDuration = 0;
                            break;
                        case 'blink':
                            validation.blinkCount = 0;
                            validation.isBlinking = false;
                            validation.lastBlink = 0;
                            break;
                    }
                    
                    // Feedback preparatorio
                    this.realTimeFeedback = `🎯 Prepárate: ${instruction.title} durante 5 segundos`;
                    
                    console.log(`🎯 Nueva instrucción ESTRICTA iniciada: ${instruction.type} (requiere ${validation.requiredDuration/1000}s)`);
                },

                // NUEVA: Completar liveness con comparación final video-selfie
                async completeLivenessWithComparison() {
                    console.log('🎥 ¡Todas las instrucciones de liveness completadas! Iniciando comparación con selfie...');
                    
                    // Detener detección facial
                    this.faceDetectionActive = false;
                    if (this.faceDetectionInterval) {
                        clearInterval(this.faceDetectionInterval);
                        this.faceDetectionInterval = null;
                    }
                    
                    // Limpiar instrucción actual
                    this.currentInstruction = null;
                    if (this.instructionTimer) {
                        clearInterval(this.instructionTimer);
                    }
                    
                    if (this.mediaRecorder && this.recording) {
                        this.mediaRecorder.stop();
                        this.recording = false;
                        this.stopRecordingTimer();
                        this.stopCamera(this.$refs.recordVideo);
                        
                        // Feedback de finalización
                        this.realTimeFeedback = '✅ ¡Verificación de liveness completada! Comparando con selfie...';
                        
                        // ⭐ NUEVA FUNCIONALIDAD: Comparar automáticamente el video con el selfie
                        setTimeout(() => {
                            this.compareVideoWithSelfie();
                        }, 2000);
                        
                    } else {
                        console.log('❌ No hay grabación de video para procesar');
                        this.realTimeFeedback = '❌ Error: No se pudo completar la grabación de video';
                    }
                },

                // NUEVA: Comparar video de liveness con selfie automáticamente
                async compareVideoWithSelfie() {
                    try {
                        console.log('🔍 Iniciando comparación automática video vs selfie...');
                        this.realTimeFeedback = '🔍 Comparando video con selfie...';
                        
                        // Verificar que tenemos selfie y video
                        if (!this.capturedSelfie) {
                            console.log('❌ No hay selfie para comparar');
                            this.realTimeFeedback = '❌ Error: No se encontró selfie para comparar';
                            return;
                        }
                        
                        if (!this.recordedVideo) {
                            console.log('❌ No hay video para comparar');
                            this.realTimeFeedback = '❌ Error: No se encontró video para comparar';
                            return;
                        }
                        
                        // Convertir video a File para envío
                        const response = await fetch(this.recordedVideo);
                        const videoBlob = await response.blob();
                        const videoFile = new File([videoBlob], 'liveness_video.webm', { type: 'video/webm' });
                        
                        // Crear FormData para envío al endpoint
                        const formData = new FormData();
                        formData.append('verificationVideo', videoFile);
                        formData.append('selfieImagePath', this.selfiePath); // Ruta del selfie guardado
                        formData.append('dniImagePath', this.dniPath);       // Ruta del DNI guardado (si existe)
                        
                        console.log('📤 Enviando datos a /kyc/verify-liveness...');
                        
                        // Enviar al endpoint de verificación de liveness
                        const verifyResponse = await fetch('/kyc/verify-liveness', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await verifyResponse.json();
                        console.log('📨 Resultado de comparación:', result);
                        
                        if (result.success) {
                            // Mostrar resultado de la comparación
                            const confidence = result.confidence || 0;
                            const recommendation = result.recommendation || 'REVIEW';
                            
                            if (recommendation === 'APPROVE' && confidence >= 60) {
                                this.realTimeFeedback = `✅ ¡Verificación exitosa! (${confidence}% confianza)`;
                                this.livenessVerificationResult = {
                                    success: true,
                                    matches_selfie: result.matches_selfie,
                                    matches_dni: result.matches_dni,
                                    confidence: confidence,
                                    message: `Persona verificada correctamente con ${confidence}% de confianza`
                                };
                            } else if (recommendation === 'REVIEW' && confidence >= 40) {
                                this.realTimeFeedback = `⚠️ Verificación requiere revisión (${confidence}% confianza)`;
                                this.livenessVerificationResult = {
                                    success: false,
                                    matches_selfie: result.matches_selfie,
                                    matches_dni: result.matches_dni,
                                    confidence: confidence,
                                    message: `Verificación requiere revisión manual: ${confidence}% confianza`
                                };
                            } else {
                                this.realTimeFeedback = `❌ Verificación fallida (${confidence}% confianza)`;
                                this.livenessVerificationResult = {
                                    success: false,
                                    matches_selfie: result.matches_selfie,
                                    matches_dni: result.matches_dni,
                                    confidence: confidence,
                                    message: `La persona del video no coincide con el selfie (${confidence}% confianza)`
                                };
                            }
                        } else {
                            this.realTimeFeedback = `❌ Error en verificación: ${result.error || 'Error desconocido'}`;
                            this.livenessVerificationResult = {
                                success: false,
                                matches_selfie: false,
                                matches_dni: false,
                                confidence: 0,
                                message: `Error técnico: ${result.error || 'No se pudo procesar el video'}`
                            };
                        }
                        
                        console.log('🎯 Resultado final de liveness:', this.livenessVerificationResult);
                        
                    } catch (error) {
                        console.error('❌ Error en comparación video-selfie:', error);
                        this.realTimeFeedback = '❌ Error técnico durante la comparación';
                        this.livenessVerificationResult = {
                            success: false,
                            matches_selfie: false,
                            matches_dni: false,
                            confidence: 0,
                            message: `Error técnico: ${error.message}`
                        };
                    }
                }
            }
        }
    </script>
</body>
</html>
